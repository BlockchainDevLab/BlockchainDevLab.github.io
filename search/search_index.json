{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"BDD-Lab: Blockchain DApp and Development Labs The hands-on labs serve two learning objectives: Deep understanding of blockchains The skill to develop blockchain applications Module A: Blockchain Basics Lab A1. Transaction exploration [ link ] Lab A2. Smart-contract programming [ link ] Lab A3. Blockchain mining [ link ] Module B: DeFi Lab B1. DEX 1: Swap settlement [ link ] Lab B2. DEX 2: AMM and pricing [ link ] Lab B3. DEX security: Arbitrage [ link ] Lab B4. DEX security: Sandwich [ link ]","title":"Home"},{"location":"#bdd-lab-blockchain-dapp-and-development-labs","text":"The hands-on labs serve two learning objectives: Deep understanding of blockchains The skill to develop blockchain applications","title":"BDD-Lab: Blockchain DApp and Development Labs"},{"location":"#_1","text":"","title":""},{"location":"#module-a-blockchain-basics","text":"Lab A1. Transaction exploration [ link ] Lab A2. Smart-contract programming [ link ] Lab A3. Blockchain mining [ link ]","title":"Module A: Blockchain Basics"},{"location":"#module-b-defi","text":"Lab B1. DEX 1: Swap settlement [ link ] Lab B2. DEX 2: AMM and pricing [ link ] Lab B3. DEX security: Arbitrage [ link ] Lab B4. DEX security: Sandwich [ link ]","title":"Module B: DeFi"},{"location":"about/","text":"Who we are FSSL Lab (Fullstack security) at Syracuse University: [ website ] Email: ytang100@syr.edu","title":"About"},{"location":"about/#who-we-are","text":"FSSL Lab (Fullstack security) at Syracuse University: [ website ] Email: ytang100@syr.edu","title":"Who we are"},{"location":"labs/A1/","text":"Lab A1: Transaction History Exploration Introduction Etherscan (https://etherscan.io/) provides a web service to explore Ethereum transactions and blocks. In this lab, you will retrieve and analyze Ethereum transaction history on etherscan by interacting with this website. Particularly, you will extract insights on transaction fees. Exercises Points CS student Finance student 1 10 Required Required 2 10 Required Required 3 10 Required Required 4 20 Required Bonus 5 30 Required Bonus 6 20 Required Bonus Exercise 1. Manually explore three transactions Suppose the following Etherscan page shows details of a particular transaction (hash 0x84ae): https://etherscan.io/tx/0x84aee3793659afeebfb89b86e6a8ffd3b9f143b3719c9b358905a83dbd71cb79 You are asked to report the average fees of three transactions, that is, transaction 0x84ae, its predecessor transaction and successor transaction. Transaction tx1 is the predecessor of tx2, if tx1 is ordered right before tx2 in the same block. Hint: You can find ordered transaction history related to block 15479087 on the following web page: https://etherscan.io/txs?block=15479087 Exercise 2. Manually explore one block Find the transaction that transfers the highest Ether \"value\" in block 15479087 . Report the transaction hash. Exercise 3. Manually explore two blocks Find the last transaction in block 15479087 and the first transaction in block 15479088 . Report the average fees of these two transactions. Hint: Assume the first transaction in a block is listed as the first row on the first page under that block on etherscan.io. Likewise, the last transaction in a block is listed as the last row on the last page under that block on etherscan.io. Exercise 4. Automatically explore 50 transactions in one block import requests from time import sleep from bs4 import BeautifulSoup def scrape_block(blocknumber, page): # the URL of the web page that we want to get transaction data api_url = \"https://etherscan.io/txs?block=\" + str(blocknumber) + \"&p=\"+str(page) # HTTP headers used to send a HTTP request headers = {'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:72.0) Gecko/20100101 Firefox/72.0'} # Pauses for 0.5 seconds before sending the next request sleep(0.5) # send the request to get data in the webpage response = requests.get(api_url, headers=headers) # get the transaction table from the response data we get for row in BeautifulSoup(response.content, 'html.parser').select('table.table-hover tbody tr'): # each row in the table is a transaction attributes = map(lambda x: x.text, row.findAll('td')) # extract transaction attributes _begin, hash, method, block, timestamp1, age, from1, _arr, to1, value1, txnfee, burnfee = attributes ######################## modify code below for each exercise ####################### print(\"transaction of ID:\", hash, \"block:\", block, \"from address\", from1, \"toaddress\", to1, \"transaction fee\",txnfee) if __name__ == \"__main__\": # entrance to the main function scrape_block(15479087, 1) In this exercise, you will run a python code to crawl data from the etherscan website automatically. The example code above crawls the etherscan web page (i.e., https://etherscan.io/txs?block=15479087) to read the first 50 transactions in block 15479087 . To run the python code, you will need a Python runtime and some libraries. If your computer does not support Python (yet), you can find installation instructions on https://www.python.org/downloads/ for both Windows and Mac machines. In addition, the Python libraries can be installed in a Python console: >>> pip3 install requests >>> pip3 install beautifulsoup4 After installation, copy the above python code to a file and run the file in a python runtime (e.g., your favorite python IDE). After running the code, you can observe transaction attributes printed on the terminal or Python console. Exercise 5. Automatically explore all transactions in one block In this exercise, you are required to report the average fee of all transactions in block 15479087 . You can modify the given code. Hint: transactions in block 15479087 are listed on three pages. Exercise 6. Automatically explore transactions across two blocks In this exercise, you are required to report the average fees of 100 transactions, which are the first 50 transactions in block 15479087 and the first 50 transactions in block 15479088 . You can modify the given code. Deliverable Report the transaction fee required for each exercise. For exercise 4, submit the screenshot that runs the crawler code on your computer. If there are too many results that cannot fit into a single screen, you can randomly choose two screens and do two screenshots. For exercise 5/6, submit your modified Python file and the screenshot that runs the code on your computer. The Python programs need to be stored in plaintext format and in separate files from your report. FAQ Question: How to verify your code is correct? Answer: Let's say your modified Python code needs to scan 100 transactions and calculate the average transaction fee. To verify your code is correct, you can change the number 100 in your program to a smaller one, say 3, and manually calculate the average fee of the 3 transactions. If the manual calculation result equals your program result, it shows that your program is likely to be correct. Question: Can I do lab exercises 4/5/6 without installing anything on my computer? Answer: Yes, it is possible. You could use Google's colab platform that supports running python code in a web browser: https://colab.research.google.com/?utm_source=scs-index . Question: How to install a Python IDE? Answer: It is not required to install an Python IDE (Python runtime is enough). But if you want, you can install the Pycharm for Python IDE (the community version) by following the instruction here: https://www.jetbrains.com/help/pycharm/installation-guide.html#toolbox. You will need to configure Python interpreter in Pycharm: https://www.jetbrains.com/help/pycharm/configuring-local-python-interpreters.html.","title":"Lab A1. Transaction exploration"},{"location":"labs/A1/#lab-a1-transaction-history-exploration","text":"","title":"Lab A1: Transaction History Exploration"},{"location":"labs/A1/#introduction","text":"Etherscan (https://etherscan.io/) provides a web service to explore Ethereum transactions and blocks. In this lab, you will retrieve and analyze Ethereum transaction history on etherscan by interacting with this website. Particularly, you will extract insights on transaction fees. Exercises Points CS student Finance student 1 10 Required Required 2 10 Required Required 3 10 Required Required 4 20 Required Bonus 5 30 Required Bonus 6 20 Required Bonus","title":"Introduction"},{"location":"labs/A1/#exercise-1-manually-explore-three-transactions","text":"Suppose the following Etherscan page shows details of a particular transaction (hash 0x84ae): https://etherscan.io/tx/0x84aee3793659afeebfb89b86e6a8ffd3b9f143b3719c9b358905a83dbd71cb79 You are asked to report the average fees of three transactions, that is, transaction 0x84ae, its predecessor transaction and successor transaction. Transaction tx1 is the predecessor of tx2, if tx1 is ordered right before tx2 in the same block. Hint: You can find ordered transaction history related to block 15479087 on the following web page: https://etherscan.io/txs?block=15479087","title":"Exercise 1. Manually explore three transactions"},{"location":"labs/A1/#exercise-2-manually-explore-one-block","text":"Find the transaction that transfers the highest Ether \"value\" in block 15479087 . Report the transaction hash.","title":"Exercise 2. Manually explore one block"},{"location":"labs/A1/#exercise-3-manually-explore-two-blocks","text":"Find the last transaction in block 15479087 and the first transaction in block 15479088 . Report the average fees of these two transactions. Hint: Assume the first transaction in a block is listed as the first row on the first page under that block on etherscan.io. Likewise, the last transaction in a block is listed as the last row on the last page under that block on etherscan.io.","title":"Exercise 3. Manually explore two blocks"},{"location":"labs/A1/#exercise-4-automatically-explore-50-transactions-in-one-block","text":"import requests from time import sleep from bs4 import BeautifulSoup def scrape_block(blocknumber, page): # the URL of the web page that we want to get transaction data api_url = \"https://etherscan.io/txs?block=\" + str(blocknumber) + \"&p=\"+str(page) # HTTP headers used to send a HTTP request headers = {'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:72.0) Gecko/20100101 Firefox/72.0'} # Pauses for 0.5 seconds before sending the next request sleep(0.5) # send the request to get data in the webpage response = requests.get(api_url, headers=headers) # get the transaction table from the response data we get for row in BeautifulSoup(response.content, 'html.parser').select('table.table-hover tbody tr'): # each row in the table is a transaction attributes = map(lambda x: x.text, row.findAll('td')) # extract transaction attributes _begin, hash, method, block, timestamp1, age, from1, _arr, to1, value1, txnfee, burnfee = attributes ######################## modify code below for each exercise ####################### print(\"transaction of ID:\", hash, \"block:\", block, \"from address\", from1, \"toaddress\", to1, \"transaction fee\",txnfee) if __name__ == \"__main__\": # entrance to the main function scrape_block(15479087, 1) In this exercise, you will run a python code to crawl data from the etherscan website automatically. The example code above crawls the etherscan web page (i.e., https://etherscan.io/txs?block=15479087) to read the first 50 transactions in block 15479087 . To run the python code, you will need a Python runtime and some libraries. If your computer does not support Python (yet), you can find installation instructions on https://www.python.org/downloads/ for both Windows and Mac machines. In addition, the Python libraries can be installed in a Python console: >>> pip3 install requests >>> pip3 install beautifulsoup4 After installation, copy the above python code to a file and run the file in a python runtime (e.g., your favorite python IDE). After running the code, you can observe transaction attributes printed on the terminal or Python console.","title":"Exercise 4. Automatically explore 50 transactions in one block"},{"location":"labs/A1/#exercise-5-automatically-explore-all-transactions-in-one-block","text":"In this exercise, you are required to report the average fee of all transactions in block 15479087 . You can modify the given code. Hint: transactions in block 15479087 are listed on three pages.","title":"Exercise 5. Automatically explore all transactions in one block"},{"location":"labs/A1/#exercise-6-automatically-explore-transactions-across-two-blocks","text":"In this exercise, you are required to report the average fees of 100 transactions, which are the first 50 transactions in block 15479087 and the first 50 transactions in block 15479088 . You can modify the given code.","title":"Exercise 6. Automatically explore transactions across two blocks"},{"location":"labs/A1/#deliverable","text":"Report the transaction fee required for each exercise. For exercise 4, submit the screenshot that runs the crawler code on your computer. If there are too many results that cannot fit into a single screen, you can randomly choose two screens and do two screenshots. For exercise 5/6, submit your modified Python file and the screenshot that runs the code on your computer. The Python programs need to be stored in plaintext format and in separate files from your report.","title":"Deliverable"},{"location":"labs/A1/#faq","text":"Question: How to verify your code is correct? Answer: Let's say your modified Python code needs to scan 100 transactions and calculate the average transaction fee. To verify your code is correct, you can change the number 100 in your program to a smaller one, say 3, and manually calculate the average fee of the 3 transactions. If the manual calculation result equals your program result, it shows that your program is likely to be correct. Question: Can I do lab exercises 4/5/6 without installing anything on my computer? Answer: Yes, it is possible. You could use Google's colab platform that supports running python code in a web browser: https://colab.research.google.com/?utm_source=scs-index . Question: How to install a Python IDE? Answer: It is not required to install an Python IDE (Python runtime is enough). But if you want, you can install the Pycharm for Python IDE (the community version) by following the instruction here: https://www.jetbrains.com/help/pycharm/installation-guide.html#toolbox. You will need to configure Python interpreter in Pycharm: https://www.jetbrains.com/help/pycharm/configuring-local-python-interpreters.html.","title":"FAQ"},{"location":"labs/A2/","text":"Lab A2: Smart-Contract Programming The learning objective of this lab is for students to acquire programming skills in smart contracts and to develop basic programs. The lab will consider an educational scenario of smart contract, that is, the rock-paper-scissors game. Lab Description : This module consists of four lab exercises where the first two exercises (1a and 1b) are to set up programming environments. The last two exercises require you to design a contract program based on the given requirement. Exercise 1b is optional and gives bonus (with 20% extra points). All other exercises are mandatory. Exercise 1a, 2, and 3 are based on the web-based Remix IDE, and 1b is on the command-line-based Solc . Solidity Solidity is an object-oriented programming language for writing smart contracts mainly on Ethereum. In addition to our lecture on Solidity programming, there are other online tutorials [ here ]. To write a Solidity program, you have to have an account payable, which is used as the constructor. Otherwise, you will not be able to make deposits/transfers in the contract. Exercise 1a: Hello-world Contract with Remix In Exercises 1, we will learn to compile and execute a given Solidity program. It is a hello-world program given as below. Function greeter takes a string argument and stores it in Variable greeting . Function greet take no argument and returns the value of Variable greeting . pragma solidity ^ 0.4.25; contract hello { /* define variable greeting of the type string */ string greeting; function greeter(string _greeting) public { greeting = _greeting; } function greet() public constant returns(string) { return greeting; } } In this exercise, we will use Remix which is a web-based IDE for contract development. It supports the full programming life cycle including contract compilation, debugging, development, and execution. More details about the Remix IDE can be found in [ link ]. 1.1 Compile the code using Start to Compile button provided in the Remix IDE. Check for the errors (if any) and resolve them. 1.2 Deploy the contract using Deploy button provided under Run tab. You can see the deployed contracts and functions deployed on the right-bottom corner. Provide the input for greeter function and click on \"transact\" button. You can see transaction being successful in the \"Remix Transactions\" section. 1.3 Click on \"greet\" button/function, you can see the string value set for \"greeting\" using \"greeter\" function will be displayed. Submit the final screenshot of running this Solidity program. Exercise 1b (with 20% bonus): Hello-world Contract with Solc and On-Campus Ethereum In this exercise, we will use a command-line programming framework solc to compile and deploy the hello-world contract to Ethereum. We will use our on-campus Ethereum network (as in the previous labs). Follow the instructions [ here ] to compile and execute the hello-world contract. Submit the screenshot of contract-execution results. Exercise 2: Find the Maximum In this exercise, you are asked to write a Solidity program to find the maximum of two values, x and y, and return that value.The Smart contact should have the following functionalities: A function that takes x and y as input Returns the maximum of x and y as output. Deploy the program and run the program in the Remix IDE [ link ] In exercise 1, if you took 1a option, you should do exercise 2 with Remix. If you took option 1b, then you can do exercise 2 with Solc. Excercise 3F (for Finance students): Payment relay in smart contract This exercise consists two steps. Step 3F1. You will need to compile and deploy the following smart contract in Remix. When running it, you need to call function pay with argument 0x0000000000000000000000000000000000000000 . Before you call the 'pay' function, click the 'showBalance' button to display the balance and take a screenshot. Then you should send a transaction to execute the 'pay' function, you need to specify the value to be 10 Ether (on the left panel of Remix IDE, there is a 'value' field, in the blank below, type 10 and select the unit to be 'ether', by default it is 'wei'), then click 'pay' button to execute the transaction. After that, click 'showBalance' button to show the balance again and take and submit your screenshot. pragma solidity ^ 0.4.25; contract payrelay { function pay(address receiver) public payable { receiver.transfer(msg.value); } function showBalance() public view returns (uint256) { return 0x0000000000000000000000000000000000000000.balance; } } Step 3F2. In the above step, you send 10 Ether to account 0x0000000000000000000000000000000000000000 through the smart contract payrelay . In this exercise, you are required to add a few lines of code in the above program to implement the following rule: The updated payrelay smart contract should only relay payment when the value is above 12 Ether. Exercise 3 (for CS students): Rock-paper-scissors game Write a Smart contract to implement the Rock-Paper-Scissors game in solidity. You can use variables to keep track of the deposit and player values.The contract should have the following functionalities: There should be two players. Consider one specific address as the owner address (where both players will deposit their money). Each player deposits an initial amount of 5 Ethers into the owner account. Once both the players deposit the money, allow them to play. While depositing the money, make sure you keep track of who is depositing and make him/her the player1 or player2 accordingly. Write a function play which takes the string parameter (Choice of the player - Rock, paper, scissors) and consider their choice only if they have deposited successfully. Once both the players have input their choices, find the winner and transfer the money as below: a. If player1 wins, send bid amount ie, 10 Ethers to player1. b. If player2 wins, send bid amount ie, 10 Ethers to player2. c. If both the players win, divide the bid amount and send to players equally. Once the game is finished, Account values (on the right-top corner of the IDE) of the designated player addresses should be updated. Make sure the player is depositing exactly 5 Ethers else the transaction should be rejected. While depositing the amount (5 Ethers in our case), Value on the right-top corner must be equivalent to 5 Ethers, in-order for the Remix to send the transaction successfully. Deliverable For all exercises, you should show the screenshot of you executing the program successfully. For instance, in Exercise 1, your screenshort should show the execution of a sequence such as greeter(\"X\") and greet() which prints the value of X . In Exercise 2,3, you should also submit the solidity program you wrote. Grading Criterion: Exercise 1a: 30 points Exercise 1b: 20 points (bonus) Exercise 2: 30 points Exercise 3: 40 points For exercise 1a, 1b, 2, if you did not submit the screenshot of successful executions of your program, you will get 5 points deducted, and 10 points deducted for exercise 3. In addition, in exercise 3, you have to demostrate your program executed successfully for cases of one winner and two winners. Missing one case will result in 5 points deduction. For exercise 3F, you have to demostrate your program executed successfully for cases of paying more than 12 Ether, and paying less than 12 Ether. Missing one case will result in 5 points deduction.","title":"Lab A2. Smart-contract programming"},{"location":"labs/A2/#lab-a2-smart-contract-programming","text":"The learning objective of this lab is for students to acquire programming skills in smart contracts and to develop basic programs. The lab will consider an educational scenario of smart contract, that is, the rock-paper-scissors game. Lab Description : This module consists of four lab exercises where the first two exercises (1a and 1b) are to set up programming environments. The last two exercises require you to design a contract program based on the given requirement. Exercise 1b is optional and gives bonus (with 20% extra points). All other exercises are mandatory. Exercise 1a, 2, and 3 are based on the web-based Remix IDE, and 1b is on the command-line-based Solc .","title":"Lab A2: Smart-Contract Programming"},{"location":"labs/A2/#solidity","text":"Solidity is an object-oriented programming language for writing smart contracts mainly on Ethereum. In addition to our lecture on Solidity programming, there are other online tutorials [ here ]. To write a Solidity program, you have to have an account payable, which is used as the constructor. Otherwise, you will not be able to make deposits/transfers in the contract.","title":"Solidity"},{"location":"labs/A2/#exercise-1a-hello-world-contract-with-remix","text":"In Exercises 1, we will learn to compile and execute a given Solidity program. It is a hello-world program given as below. Function greeter takes a string argument and stores it in Variable greeting . Function greet take no argument and returns the value of Variable greeting . pragma solidity ^ 0.4.25; contract hello { /* define variable greeting of the type string */ string greeting; function greeter(string _greeting) public { greeting = _greeting; } function greet() public constant returns(string) { return greeting; } } In this exercise, we will use Remix which is a web-based IDE for contract development. It supports the full programming life cycle including contract compilation, debugging, development, and execution. More details about the Remix IDE can be found in [ link ]. 1.1 Compile the code using Start to Compile button provided in the Remix IDE. Check for the errors (if any) and resolve them. 1.2 Deploy the contract using Deploy button provided under Run tab. You can see the deployed contracts and functions deployed on the right-bottom corner. Provide the input for greeter function and click on \"transact\" button. You can see transaction being successful in the \"Remix Transactions\" section. 1.3 Click on \"greet\" button/function, you can see the string value set for \"greeting\" using \"greeter\" function will be displayed. Submit the final screenshot of running this Solidity program.","title":"Exercise 1a: Hello-world Contract with Remix"},{"location":"labs/A2/#exercise-1b-with-20-bonus-hello-world-contract-with-solc-and-on-campus-ethereum","text":"In this exercise, we will use a command-line programming framework solc to compile and deploy the hello-world contract to Ethereum. We will use our on-campus Ethereum network (as in the previous labs). Follow the instructions [ here ] to compile and execute the hello-world contract. Submit the screenshot of contract-execution results.","title":"Exercise 1b (with 20% bonus): Hello-world Contract with Solc and On-Campus Ethereum"},{"location":"labs/A2/#exercise-2-find-the-maximum","text":"In this exercise, you are asked to write a Solidity program to find the maximum of two values, x and y, and return that value.The Smart contact should have the following functionalities: A function that takes x and y as input Returns the maximum of x and y as output. Deploy the program and run the program in the Remix IDE [ link ] In exercise 1, if you took 1a option, you should do exercise 2 with Remix. If you took option 1b, then you can do exercise 2 with Solc.","title":"Exercise 2: Find the Maximum"},{"location":"labs/A2/#excercise-3f-for-finance-students-payment-relay-in-smart-contract","text":"This exercise consists two steps. Step 3F1. You will need to compile and deploy the following smart contract in Remix. When running it, you need to call function pay with argument 0x0000000000000000000000000000000000000000 . Before you call the 'pay' function, click the 'showBalance' button to display the balance and take a screenshot. Then you should send a transaction to execute the 'pay' function, you need to specify the value to be 10 Ether (on the left panel of Remix IDE, there is a 'value' field, in the blank below, type 10 and select the unit to be 'ether', by default it is 'wei'), then click 'pay' button to execute the transaction. After that, click 'showBalance' button to show the balance again and take and submit your screenshot. pragma solidity ^ 0.4.25; contract payrelay { function pay(address receiver) public payable { receiver.transfer(msg.value); } function showBalance() public view returns (uint256) { return 0x0000000000000000000000000000000000000000.balance; } } Step 3F2. In the above step, you send 10 Ether to account 0x0000000000000000000000000000000000000000 through the smart contract payrelay . In this exercise, you are required to add a few lines of code in the above program to implement the following rule: The updated payrelay smart contract should only relay payment when the value is above 12 Ether.","title":"Excercise 3F (for Finance students): Payment relay in smart contract"},{"location":"labs/A2/#exercise-3-for-cs-students-rock-paper-scissors-game","text":"Write a Smart contract to implement the Rock-Paper-Scissors game in solidity. You can use variables to keep track of the deposit and player values.The contract should have the following functionalities: There should be two players. Consider one specific address as the owner address (where both players will deposit their money). Each player deposits an initial amount of 5 Ethers into the owner account. Once both the players deposit the money, allow them to play. While depositing the money, make sure you keep track of who is depositing and make him/her the player1 or player2 accordingly. Write a function play which takes the string parameter (Choice of the player - Rock, paper, scissors) and consider their choice only if they have deposited successfully. Once both the players have input their choices, find the winner and transfer the money as below: a. If player1 wins, send bid amount ie, 10 Ethers to player1. b. If player2 wins, send bid amount ie, 10 Ethers to player2. c. If both the players win, divide the bid amount and send to players equally. Once the game is finished, Account values (on the right-top corner of the IDE) of the designated player addresses should be updated. Make sure the player is depositing exactly 5 Ethers else the transaction should be rejected. While depositing the amount (5 Ethers in our case), Value on the right-top corner must be equivalent to 5 Ethers, in-order for the Remix to send the transaction successfully.","title":"Exercise 3 (for CS students): Rock-paper-scissors game"},{"location":"labs/A2/#deliverable","text":"For all exercises, you should show the screenshot of you executing the program successfully. For instance, in Exercise 1, your screenshort should show the execution of a sequence such as greeter(\"X\") and greet() which prints the value of X . In Exercise 2,3, you should also submit the solidity program you wrote.","title":"Deliverable"},{"location":"labs/A2/#grading-criterion","text":"Exercise 1a: 30 points Exercise 1b: 20 points (bonus) Exercise 2: 30 points Exercise 3: 40 points For exercise 1a, 1b, 2, if you did not submit the screenshot of successful executions of your program, you will get 5 points deducted, and 10 points deducted for exercise 3. In addition, in exercise 3, you have to demostrate your program executed successfully for cases of one winner and two winners. Missing one case will result in 5 points deduction. For exercise 3F, you have to demostrate your program executed successfully for cases of paying more than 12 Ether, and paying less than 12 Ether. Missing one case will result in 5 points deduction.","title":"Grading Criterion:"},{"location":"labs/A2/CrashCourse_SoliditySyntax/","text":"","title":"CrashCourse SoliditySyntax"},{"location":"labs/A2/README_solc/","text":"Lab L2-4.1/Exercise 1b: Hello-world on Solc and Ethereum Start your Ethereum VM in VirtualBox and open a terminal there. Install Solc Method 1a. Installing all versions of solc and use version 0.4.25 : sudo python3 -m pip install py-solc sudo python3 -m solc.install v0.4.25 sudo chmod 777 ~/.py-solc/solc-v0.4.25/bin/solc sudo mv ~/.py-solc/solc-v0.4.25/bin/solc /usr/bin/solc solc --version Method 1b. sudo add-apt-repository ppa:ethereum/ethereum sudo apt-get update sudo apt-get install solc You will find solc under the path /usr/bin . For MacOs , please find the install instruction at: https://docs.soliditylang.org/en/v0.8.9/installing-solidity.html#macos-packages. Set up the Ethereum client for this lab. We will reuse your client data (e.g., accounts and balances) created in the previous lab, and connect to the same Ethereum network. cd ~ cp -r lab1 lab2 cd lab2 Create a smart-contract file. Copy the text of the above hello-world program and save it in a file ~/lab2/hello.sol . You can use a text editor of your preference to do this, such as vim , emacs , gedit . Compile the contract file using solc in the command below. You may also try soljs as the compiler. solc -o . --bin --abi hello.sol Note : If your solc compiler version is after 0.5.0, you may need to use the following hello.sol source code. pragma solidity ^ 0.5.0; contract hello { /* define variable greeting of the type string */ string greeting; function greeter(string memory _greeting) public { greeting = _greeting; } function greet() public view returns(string memory) { return greeting; } } After compilation, there should be two files generated: hello.abi and hello.bin . - File hello.bin stores the compiled \"binary\" code. This is the code directly executed by miners. - File hello.abi defines the interface through which the compiled code interacts with the execution platform (or EVM). Like ABI, it defines how the binary code in .bin should be interpreted in EVM. hello.abi (original) [{\"constant\":true,\"inputs\":[],\"name\":\"greet\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_greeting\",\"type\":\"string\"}],\"name\":\"greeter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}] hello.bin (original) 608060405234801561001057600080fd5b506102d7806100206000396000f30060806040526004361061004c576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff168063cfae321714610051578063faf27bca146100e1575b600080fd5b34801561005d57600080fd5b5061006661014a565b6040518080602001828103825283818151815260200191508051906020019080838360005b838110156100a657808201518184015260208101905061008b565b50505050905090810190601f1680156100d35780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b3480156100ed57600080fd5b50610148600480360381019080803590602001908201803590602001908080601f01602080910402602001604051908101604052809392919081815260200183838082843782019150505050505091929192905050506101ec565b005b606060008054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156101e25780601f106101b7576101008083540402835291602001916101e2565b820191906000526020600020905b8154815290600101906020018083116101c557829003601f168201915b5050505050905090565b8060009080519060200190610202929190610206565b5050565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061024757805160ff1916838001178555610275565b82800160010185558215610275579182015b82811115610274578251825591602001919060010190610259565b5b5090506102829190610286565b5090565b6102a891905b808211156102a457600081600090555060010161028c565b5090565b905600a165627a7a72305820a06cc690f3e38c276b8c4e70ec8a61437d1c71e3779bdfbd2f8d12bc3601f20a0029 To deploy the two compiled files, we need to first edit them as below. hello.abi (modified) var helloContract = eth.contract([{\"constant\":true,\"inputs\":[],\"name\":\"greet\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_greeting\",\"type\":\"string\"}],\"name\":\"greeter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]) hello.bin (modified) personal.unlockAccount(eth.accounts[0]) var helloVar = helloContract.new({from:eth.accounts[0], data:\"0x608060405234801561001057600080fd5b506102d7806100206000396000f30060806040526004361061004c576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff168063cfae321714610051578063faf27bca146100e1575b600080fd5b34801561005d57600080fd5b5061006661014a565b6040518080602001828103825283818151815260200191508051906020019080838360005b838110156100a657808201518184015260208101905061008b565b50505050905090810190601f1680156100d35780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b3480156100ed57600080fd5b50610148600480360381019080803590602001908201803590602001908080601f01602080910402602001604051908101604052809392919081815260200183838082843782019150505050505091929192905050506101ec565b005b606060008054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156101e25780601f106101b7576101008083540402835291602001916101e2565b820191906000526020600020905b8154815290600101906020018083116101c557829003601f168201915b5050505050905090565b8060009080519060200190610202929190610206565b5050565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061024757805160ff1916838001178555610275565b82800160010185558215610275579182015b82811115610274578251825591602001919060010190610259565b5b5090506102829190610286565b5090565b6102a891905b808211156102a457600081600090555060010161028c565b5090565b905600a165627a7a72305820a06cc690f3e38c276b8c4e70ec8a61437d1c71e3779bdfbd2f8d12bc3601f20a0029\",gas:500000}) Deploy the smart contract by first connecting to the Ethereum network (these steps are the same as per the last lab) $ geth --datadir bkc_data init ~/lab2/genesis.json # create a database that uses this genesis block $ geth --datadir bkc_data --rpc --networkid 89992018 --allow-insecure-unlock --bootnodes \"enode://a3b871242d7e40dc517514f6a995c2514cbe4907827275e3164ff43fb95d1d977d77e66da2e992c94a0843337fdfb86c9a02254e414db8ff0d6dbba15f32eb22@128.230.210.231:30301\" console 2>console.log Load and run the script to deploy smart contract > loadScript(\"hello.abi\") > loadScript(\"hello.bin\") You will see the message below in console log file. For future use, take a note of both contract address and transaction hash value. INFO [06-26|14:39:04] Submitted contract creation fullhash=0x3a866d157afb43afaef5e33ef7ec61ab0dfe2edf36783f8a332ee8d622dadea9 contract=0x5dDd255aBa54b65595BB80dDd492Ea260bBA23a1 Check if the transaction is included by eth.getTransaction . If not, then you have to enable mining on your Geth node to include the contract creation transaction. Open a new terminal and run the following command. cd lab2 geth attach bkc_data/geth.ipc miner.start(1) Execute the smart-contract program by running the following commands. They sequentially call two functions in the deployed contracts, greeter and greet . Note: in the below command, a gas amount of 700,000 is specified. > helloVar.greeter.sendTransaction(\"Hello\",{from:eth.accounts[0],gas:700000}) \"0xae7ef314af8923baf12d93d17cbfc62ba93dab325fbae94c0a5d9bec4578aa62\" > helloVar.greet.call() \"Hello\" Deliverable : Finish the above commands to execute the hello-world contract. Submit the screenshot of contract-execution results.","title":"README solc"},{"location":"labs/A2/README_solc/#lab-l2-41exercise-1b-hello-world-on-solc-and-ethereum","text":"Start your Ethereum VM in VirtualBox and open a terminal there. Install Solc Method 1a. Installing all versions of solc and use version 0.4.25 : sudo python3 -m pip install py-solc sudo python3 -m solc.install v0.4.25 sudo chmod 777 ~/.py-solc/solc-v0.4.25/bin/solc sudo mv ~/.py-solc/solc-v0.4.25/bin/solc /usr/bin/solc solc --version Method 1b. sudo add-apt-repository ppa:ethereum/ethereum sudo apt-get update sudo apt-get install solc You will find solc under the path /usr/bin . For MacOs , please find the install instruction at: https://docs.soliditylang.org/en/v0.8.9/installing-solidity.html#macos-packages. Set up the Ethereum client for this lab. We will reuse your client data (e.g., accounts and balances) created in the previous lab, and connect to the same Ethereum network. cd ~ cp -r lab1 lab2 cd lab2 Create a smart-contract file. Copy the text of the above hello-world program and save it in a file ~/lab2/hello.sol . You can use a text editor of your preference to do this, such as vim , emacs , gedit . Compile the contract file using solc in the command below. You may also try soljs as the compiler. solc -o . --bin --abi hello.sol Note : If your solc compiler version is after 0.5.0, you may need to use the following hello.sol source code. pragma solidity ^ 0.5.0; contract hello { /* define variable greeting of the type string */ string greeting; function greeter(string memory _greeting) public { greeting = _greeting; } function greet() public view returns(string memory) { return greeting; } } After compilation, there should be two files generated: hello.abi and hello.bin . - File hello.bin stores the compiled \"binary\" code. This is the code directly executed by miners. - File hello.abi defines the interface through which the compiled code interacts with the execution platform (or EVM). Like ABI, it defines how the binary code in .bin should be interpreted in EVM. hello.abi (original) [{\"constant\":true,\"inputs\":[],\"name\":\"greet\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_greeting\",\"type\":\"string\"}],\"name\":\"greeter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}] hello.bin (original) 608060405234801561001057600080fd5b506102d7806100206000396000f30060806040526004361061004c576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff168063cfae321714610051578063faf27bca146100e1575b600080fd5b34801561005d57600080fd5b5061006661014a565b6040518080602001828103825283818151815260200191508051906020019080838360005b838110156100a657808201518184015260208101905061008b565b50505050905090810190601f1680156100d35780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b3480156100ed57600080fd5b50610148600480360381019080803590602001908201803590602001908080601f01602080910402602001604051908101604052809392919081815260200183838082843782019150505050505091929192905050506101ec565b005b606060008054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156101e25780601f106101b7576101008083540402835291602001916101e2565b820191906000526020600020905b8154815290600101906020018083116101c557829003601f168201915b5050505050905090565b8060009080519060200190610202929190610206565b5050565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061024757805160ff1916838001178555610275565b82800160010185558215610275579182015b82811115610274578251825591602001919060010190610259565b5b5090506102829190610286565b5090565b6102a891905b808211156102a457600081600090555060010161028c565b5090565b905600a165627a7a72305820a06cc690f3e38c276b8c4e70ec8a61437d1c71e3779bdfbd2f8d12bc3601f20a0029 To deploy the two compiled files, we need to first edit them as below. hello.abi (modified) var helloContract = eth.contract([{\"constant\":true,\"inputs\":[],\"name\":\"greet\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_greeting\",\"type\":\"string\"}],\"name\":\"greeter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]) hello.bin (modified) personal.unlockAccount(eth.accounts[0]) var helloVar = helloContract.new({from:eth.accounts[0], data:\"0x608060405234801561001057600080fd5b506102d7806100206000396000f30060806040526004361061004c576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff168063cfae321714610051578063faf27bca146100e1575b600080fd5b34801561005d57600080fd5b5061006661014a565b6040518080602001828103825283818151815260200191508051906020019080838360005b838110156100a657808201518184015260208101905061008b565b50505050905090810190601f1680156100d35780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b3480156100ed57600080fd5b50610148600480360381019080803590602001908201803590602001908080601f01602080910402602001604051908101604052809392919081815260200183838082843782019150505050505091929192905050506101ec565b005b606060008054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156101e25780601f106101b7576101008083540402835291602001916101e2565b820191906000526020600020905b8154815290600101906020018083116101c557829003601f168201915b5050505050905090565b8060009080519060200190610202929190610206565b5050565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061024757805160ff1916838001178555610275565b82800160010185558215610275579182015b82811115610274578251825591602001919060010190610259565b5b5090506102829190610286565b5090565b6102a891905b808211156102a457600081600090555060010161028c565b5090565b905600a165627a7a72305820a06cc690f3e38c276b8c4e70ec8a61437d1c71e3779bdfbd2f8d12bc3601f20a0029\",gas:500000}) Deploy the smart contract by first connecting to the Ethereum network (these steps are the same as per the last lab) $ geth --datadir bkc_data init ~/lab2/genesis.json # create a database that uses this genesis block $ geth --datadir bkc_data --rpc --networkid 89992018 --allow-insecure-unlock --bootnodes \"enode://a3b871242d7e40dc517514f6a995c2514cbe4907827275e3164ff43fb95d1d977d77e66da2e992c94a0843337fdfb86c9a02254e414db8ff0d6dbba15f32eb22@128.230.210.231:30301\" console 2>console.log Load and run the script to deploy smart contract > loadScript(\"hello.abi\") > loadScript(\"hello.bin\") You will see the message below in console log file. For future use, take a note of both contract address and transaction hash value. INFO [06-26|14:39:04] Submitted contract creation fullhash=0x3a866d157afb43afaef5e33ef7ec61ab0dfe2edf36783f8a332ee8d622dadea9 contract=0x5dDd255aBa54b65595BB80dDd492Ea260bBA23a1 Check if the transaction is included by eth.getTransaction . If not, then you have to enable mining on your Geth node to include the contract creation transaction. Open a new terminal and run the following command. cd lab2 geth attach bkc_data/geth.ipc miner.start(1) Execute the smart-contract program by running the following commands. They sequentially call two functions in the deployed contracts, greeter and greet . Note: in the below command, a gas amount of 700,000 is specified. > helloVar.greeter.sendTransaction(\"Hello\",{from:eth.accounts[0],gas:700000}) \"0xae7ef314af8923baf12d93d17cbfc62ba93dab325fbae94c0a5d9bec4578aa62\" > helloVar.greet.call() \"Hello\" Deliverable : Finish the above commands to execute the hello-world contract. Submit the screenshot of contract-execution results.","title":"Lab L2-4.1/Exercise 1b: Hello-world on Solc and Ethereum"},{"location":"labs/A3/","text":"Lab A3: Mining in an On-Campus Ethereum Network In this lab, you are given the initial state that a custom Blockchain network of several miners is hosted on an on-campus machine which has been running for several days before the class. The Blockchain machine also runs a daemon that periodically instructs some miner to conduct transactions with other miners. Prerequisite Have experience in Linux shell commands Understand Ethereum Lab Environment Setup 1A. Download our VM with Ethereum Install VirtualBox on your computer: https://www.virtualbox.org/wiki/Downloads . Choose Ubuntu-64 bit option while installing the VM. Download our prebuilt VirtualBox image from [ here ]. Import the image as Appliance inside VirtualBox. The credential for the VM is: username: user1 , password: blockchainsu . Script 1a : mkdir -p ~/lab1/bkc_data cd ~/lab1 gedit genesis.json Copy this online file [ link ] to the gedit and save it (by hitting control+S in Ubuntu). 1B. (Alternative option) Install Ethereum on your OS If you are good with option 1A, you can skip 1B. This step is for who want to install Ethereum on their OS. We will use Geth , the Ethereum client implemented in Language Go . You can choose to either install the Geth on you own machine or the Linux machine running on VirtualBox. See here for more information. Ubuntu Users Here is the instructions to install the Geth for Ubuntu. Even when you are not using Ubuntu as native OS, you can set up VirtualBox and download a Ubuntu-1604-LTS image from [ here ]. This image is typically 1 GB, much smaller than the 7 GB image above. To set up an empty Ubuntu OS on VirtualBox, here is a useful [ link ]. Script 1b : sudo apt-get install software-properties-common sudo add-apt-repository -y ppa:ethereum/ethereum sudo apt-get update sudo apt-get install ethereum Mac Users Script 1bb : brew tap ethereum/ethereum brew install ethereum Windows Users https://github.com/ethereum/go-ethereum/wiki/Installation-instructions-for-Windows 2. Join the Blockchain network 2.1 Connect to the Blockchain Gateway (Bootnode) : Every blockchain starts with the genesis block. When you run geth with default settings for the first time, the main net genesis block is committed to the database. For a private network, you usually want a different genesis block. We have a pre-defined custom [ genesis.json ] file. The config section ensures that certain protocol upgrades are immediately available. The alloc section pre-funds accounts, which is currently empty. Following the instructions below to run geth. Script 2.1 : mkdir -p ~/lab1/bkc_data cd ~/lab1 geth --datadir bkc_data init ~/lab1/genesis.json # create a database that uses this genesis block geth --datadir bkc_data --rpc --networkid 89992018 --bootnodes \"enode://764242277ec5ad520944549199ecc590e99f4cb379e82441ec4027a25624ca88a7b177db15e4b943fc295288a18885b7a29f0a91b624ddad0629e70752ed6acd@128.230.210.231:30301\" console 2>console.log Note: If the geth failed to start due to errors such as 'undefined flags rpc', try to replace 'rpc' with 'http'. In the last command above, --networkid specify the private network ID. Connections between nodes are valid only if peers have identical protocol version and network ID, you can effectively isolate your network by setting either of these to a non default value. --bootnode option specify the bootnode address, following the format [nodeID]:IP:port . Every subsequent Geth node pointed to the bootnode for peer discovery. This page describes the options for geth commands. Check the connectivity by running: Script 2.3 : > admin.peers This command should return non-empty text about the peer nodes connected by your miner node. 3A. Get Coins by Transactions Script 3a.1 : > personal.newAccount() # create an Account > eth.accounts # check accounts Publish your account identity to the public bulletin (https://goo.gl/6WHAq9). The TA will send some coins to your account. After that, you can check the balance. Script 3a.2 : > web3.fromWei(eth.getBalance(eth.accounts[0]),\"ether\") 3B. Get Coins by Mining Before mining, the coinbase has to be specified to one personal account, where your earnings will be settled. Run following commands to create a new account, and set it as coinbase. Script 3b.1 : > personal.newAccount() # create an Account > eth.accounts # check accounts > miner.setEtherbase(eth.accounts[0]) # that address that will receive your earnings You can now start/stop the miner. If mining doesn't seem to work, you may try to unlock your account and start mining again: > personal.unlockAccount(\u201caccountAddress\u201d, \u201caccountPassword\u201d) > personal.unlockAccount(\u201caccountAddress\u201d, \u201caccountPassword\u201d, expiration_time) Script 3b.2 : > miner.start(1)# one thread in this case, you can increase the thread number to increase the mining power so that you can compete with remote server. > miner.stop() Mining takes a while to get start, you can monitor the event log by Script 3b.3 : tail -f ~/lab1/console.log To know currently you are mining or not, you can run Script 3b.4 : > eth.hashrate # get the current mining power > eth.blockNumber # current top block. If you find your account has non-zero balance, you get some coins through mining: Script 3b.5 : > web3.fromWei(eth.getBalance(eth.accounts[0]),\"ether\") The list of Geth commands can be found on [ this page ]. Lab Tasks The tasks in this lab require to inspect and modify the content of Blockchain. In addition to the Ethereum commands you used above, there are other relevant commands as below. > eth.accounts[0] # check the account id > eth.getBalance(<account>) # check the balance for one account, the argument is account id > web3.fromWei(<value>,\"ether\") # convert Wei to Ether > web3.toWei(<value>,\"ether\") #convert Ether to Wei > eth.blockNumber # check the latest block number on the chain > eth.getBlock(eth.blockNumber-3) # display a certain block > eth.getBlock('latest', true) # display the latest block > eth.getBlock('pending', true) # display the pending block > eth.sendTransaction({from:eth.accounts[0], to:\"0xda1b60c80502fea9977bab42dcebad05c289dcd2\", value:web3.toWei(1,\"ether\")}) #eth.sendTransaction({from:senderAccount, to:receiverAccount, value: amount}) > eth.getTransaction(\"0x57dfe8f7f4760f09cd76a8b09000fd43275d798503ed88ed6d8b39c1d5ce3157\") > loadScript(\"/path/to/script.js\") #run script.js (all the commands there) inside the geth console. Task 1: After you started mining, show the coins that you have mined. Then wait 1 minute, check the balance again. Task 2: Show the latest five blocks and the latest two transaction confirmed in the blockchain. Then wait 1 minute, show the blockchain again and see how if it is extended by new blocks over time. (Hint: To find the latest transaction on the blockchain, you can iterate through the blocks and check the transaction(s) in them. To iterate through the blocks, you can use JavaScript. Alternatively, you can programming with Python with the Web3py library, see web3py.md for the sample code.) Task 3: Submit a transaction, say tx1 , to the blockchain. You create another account as the recipient (seller) of the transaction. Show whether transaction tx1 is included in the Blockchain; if not wait for a while, check again. Note 1: The above command will return a hash tag which served as the ID of the transaction, you could use that ID to query the transaction in the future. Note 2: Ether is the name of the currency used within Ethereum. Wei is the smallest unit in Ethereum. 1 Ether = 10^18 Wei. The account balance and transfer amount are shown in Wei. You can use the converter utility web3.fromWei and web3.toWei to convert between Ether and Wei. Deliverable For each task, you should submit the following: The script program consisting of the Geth commands The screenshot that shows your script has run successfully on your computer Make sure include your name in the screenshot. For instance, you can open a text editor and type your name in it. FAQ/Trouble shooting Q1: When sending transaction, I got this error: \"account is locked\" Answer: Before sending transactions, you may need to unlock your personal wallet/account and input passphrase. Example: personal.unlockAccount(eth.accounts[0]) Q2: In Mining, I keep getting zero balance? Answer: One of possible reasons is your VM/OS does not have enough memory. We recommend at least 4 GB for mining. If you don't run mining, you don't have to allocate large memory for this lab. Q3: When my terminal crashes in VM (e.g., during mining), I cannot restart the geth properly. Answer: You can restart the VM to get around this issue. (Terminal crash may mess up network stack in your VM which geth depends on). Q4: How to check if my node is mining? Answer: You can check by running \"eth.mining\", it returns \"true\" or \"false\" to indicate if the mining is on-going or not. Note: Command eth.hashrate may return \"0\" even if the mining process is active. Q5: I choose options 1.A to setup the environment, and it is running out of disk memory, what would I do? Answer: You have two options. 1, You can choose to install a Ubuntu inside of VirtualBox and start from option 1.B (recommended) 2, you can add a new virtual hard disk to your current virtual machine. Step 1: Follow the instructions in the below link (but skipping the last step - \"mounting the partition\") [ Add Disk Storage ]. Step 2: Run the below command to cleanup some space sudo rm -rf /var/* Step 3. Run the below command to mount the new disk to the home directory. sudo mount /dev/sdb1 ~ Q6: Why does admin.peers return null sometimes? admin.peers returns you the information about connected remote nodes and it seems like the method uses public IP addresses for this. Few students mentioned that admin.peers runs successfully when they run it outside of the school network while it failed in the shcool network. Even though it's returning null, you should still be able to mine your own coins if you connected to the private blockchain network successfully. Q7: Out of space? Clear the folder ~/.ethereum/ after you finish the lab. Also, clear the folder specified through ``--datadir'' when starting geth.","title":"Lab A3. Blockchain mining"},{"location":"labs/A3/#lab-a3-mining-in-an-on-campus-ethereum-network","text":"In this lab, you are given the initial state that a custom Blockchain network of several miners is hosted on an on-campus machine which has been running for several days before the class. The Blockchain machine also runs a daemon that periodically instructs some miner to conduct transactions with other miners.","title":"Lab A3: Mining in an On-Campus Ethereum Network"},{"location":"labs/A3/#prerequisite","text":"Have experience in Linux shell commands Understand Ethereum","title":"Prerequisite"},{"location":"labs/A3/#lab-environment-setup","text":"","title":"Lab Environment Setup"},{"location":"labs/A3/#1a-download-our-vm-with-ethereum","text":"Install VirtualBox on your computer: https://www.virtualbox.org/wiki/Downloads . Choose Ubuntu-64 bit option while installing the VM. Download our prebuilt VirtualBox image from [ here ]. Import the image as Appliance inside VirtualBox. The credential for the VM is: username: user1 , password: blockchainsu . Script 1a : mkdir -p ~/lab1/bkc_data cd ~/lab1 gedit genesis.json Copy this online file [ link ] to the gedit and save it (by hitting control+S in Ubuntu).","title":"1A. Download our VM with Ethereum"},{"location":"labs/A3/#1b-alternative-option-install-ethereum-on-your-os","text":"If you are good with option 1A, you can skip 1B. This step is for who want to install Ethereum on their OS. We will use Geth , the Ethereum client implemented in Language Go . You can choose to either install the Geth on you own machine or the Linux machine running on VirtualBox. See here for more information. Ubuntu Users Here is the instructions to install the Geth for Ubuntu. Even when you are not using Ubuntu as native OS, you can set up VirtualBox and download a Ubuntu-1604-LTS image from [ here ]. This image is typically 1 GB, much smaller than the 7 GB image above. To set up an empty Ubuntu OS on VirtualBox, here is a useful [ link ]. Script 1b : sudo apt-get install software-properties-common sudo add-apt-repository -y ppa:ethereum/ethereum sudo apt-get update sudo apt-get install ethereum Mac Users Script 1bb : brew tap ethereum/ethereum brew install ethereum Windows Users https://github.com/ethereum/go-ethereum/wiki/Installation-instructions-for-Windows","title":"1B. (Alternative option) Install Ethereum on your OS"},{"location":"labs/A3/#2-join-the-blockchain-network","text":"2.1 Connect to the Blockchain Gateway (Bootnode) : Every blockchain starts with the genesis block. When you run geth with default settings for the first time, the main net genesis block is committed to the database. For a private network, you usually want a different genesis block. We have a pre-defined custom [ genesis.json ] file. The config section ensures that certain protocol upgrades are immediately available. The alloc section pre-funds accounts, which is currently empty. Following the instructions below to run geth. Script 2.1 : mkdir -p ~/lab1/bkc_data cd ~/lab1 geth --datadir bkc_data init ~/lab1/genesis.json # create a database that uses this genesis block geth --datadir bkc_data --rpc --networkid 89992018 --bootnodes \"enode://764242277ec5ad520944549199ecc590e99f4cb379e82441ec4027a25624ca88a7b177db15e4b943fc295288a18885b7a29f0a91b624ddad0629e70752ed6acd@128.230.210.231:30301\" console 2>console.log Note: If the geth failed to start due to errors such as 'undefined flags rpc', try to replace 'rpc' with 'http'. In the last command above, --networkid specify the private network ID. Connections between nodes are valid only if peers have identical protocol version and network ID, you can effectively isolate your network by setting either of these to a non default value. --bootnode option specify the bootnode address, following the format [nodeID]:IP:port . Every subsequent Geth node pointed to the bootnode for peer discovery. This page describes the options for geth commands. Check the connectivity by running: Script 2.3 : > admin.peers This command should return non-empty text about the peer nodes connected by your miner node.","title":"2. Join the Blockchain network"},{"location":"labs/A3/#3a-get-coins-by-transactions","text":"Script 3a.1 : > personal.newAccount() # create an Account > eth.accounts # check accounts Publish your account identity to the public bulletin (https://goo.gl/6WHAq9). The TA will send some coins to your account. After that, you can check the balance. Script 3a.2 : > web3.fromWei(eth.getBalance(eth.accounts[0]),\"ether\")","title":"3A. Get Coins by Transactions"},{"location":"labs/A3/#3b-get-coins-by-mining","text":"Before mining, the coinbase has to be specified to one personal account, where your earnings will be settled. Run following commands to create a new account, and set it as coinbase. Script 3b.1 : > personal.newAccount() # create an Account > eth.accounts # check accounts > miner.setEtherbase(eth.accounts[0]) # that address that will receive your earnings You can now start/stop the miner. If mining doesn't seem to work, you may try to unlock your account and start mining again: > personal.unlockAccount(\u201caccountAddress\u201d, \u201caccountPassword\u201d) > personal.unlockAccount(\u201caccountAddress\u201d, \u201caccountPassword\u201d, expiration_time) Script 3b.2 : > miner.start(1)# one thread in this case, you can increase the thread number to increase the mining power so that you can compete with remote server. > miner.stop() Mining takes a while to get start, you can monitor the event log by Script 3b.3 : tail -f ~/lab1/console.log To know currently you are mining or not, you can run Script 3b.4 : > eth.hashrate # get the current mining power > eth.blockNumber # current top block. If you find your account has non-zero balance, you get some coins through mining: Script 3b.5 : > web3.fromWei(eth.getBalance(eth.accounts[0]),\"ether\") The list of Geth commands can be found on [ this page ].","title":"3B. Get Coins by Mining"},{"location":"labs/A3/#lab-tasks","text":"The tasks in this lab require to inspect and modify the content of Blockchain. In addition to the Ethereum commands you used above, there are other relevant commands as below. > eth.accounts[0] # check the account id > eth.getBalance(<account>) # check the balance for one account, the argument is account id > web3.fromWei(<value>,\"ether\") # convert Wei to Ether > web3.toWei(<value>,\"ether\") #convert Ether to Wei > eth.blockNumber # check the latest block number on the chain > eth.getBlock(eth.blockNumber-3) # display a certain block > eth.getBlock('latest', true) # display the latest block > eth.getBlock('pending', true) # display the pending block > eth.sendTransaction({from:eth.accounts[0], to:\"0xda1b60c80502fea9977bab42dcebad05c289dcd2\", value:web3.toWei(1,\"ether\")}) #eth.sendTransaction({from:senderAccount, to:receiverAccount, value: amount}) > eth.getTransaction(\"0x57dfe8f7f4760f09cd76a8b09000fd43275d798503ed88ed6d8b39c1d5ce3157\") > loadScript(\"/path/to/script.js\") #run script.js (all the commands there) inside the geth console. Task 1: After you started mining, show the coins that you have mined. Then wait 1 minute, check the balance again. Task 2: Show the latest five blocks and the latest two transaction confirmed in the blockchain. Then wait 1 minute, show the blockchain again and see how if it is extended by new blocks over time. (Hint: To find the latest transaction on the blockchain, you can iterate through the blocks and check the transaction(s) in them. To iterate through the blocks, you can use JavaScript. Alternatively, you can programming with Python with the Web3py library, see web3py.md for the sample code.) Task 3: Submit a transaction, say tx1 , to the blockchain. You create another account as the recipient (seller) of the transaction. Show whether transaction tx1 is included in the Blockchain; if not wait for a while, check again. Note 1: The above command will return a hash tag which served as the ID of the transaction, you could use that ID to query the transaction in the future. Note 2: Ether is the name of the currency used within Ethereum. Wei is the smallest unit in Ethereum. 1 Ether = 10^18 Wei. The account balance and transfer amount are shown in Wei. You can use the converter utility web3.fromWei and web3.toWei to convert between Ether and Wei.","title":"Lab Tasks"},{"location":"labs/A3/#deliverable","text":"For each task, you should submit the following: The script program consisting of the Geth commands The screenshot that shows your script has run successfully on your computer Make sure include your name in the screenshot. For instance, you can open a text editor and type your name in it.","title":"Deliverable"},{"location":"labs/A3/#faqtrouble-shooting","text":"Q1: When sending transaction, I got this error: \"account is locked\" Answer: Before sending transactions, you may need to unlock your personal wallet/account and input passphrase. Example: personal.unlockAccount(eth.accounts[0]) Q2: In Mining, I keep getting zero balance? Answer: One of possible reasons is your VM/OS does not have enough memory. We recommend at least 4 GB for mining. If you don't run mining, you don't have to allocate large memory for this lab. Q3: When my terminal crashes in VM (e.g., during mining), I cannot restart the geth properly. Answer: You can restart the VM to get around this issue. (Terminal crash may mess up network stack in your VM which geth depends on). Q4: How to check if my node is mining? Answer: You can check by running \"eth.mining\", it returns \"true\" or \"false\" to indicate if the mining is on-going or not. Note: Command eth.hashrate may return \"0\" even if the mining process is active. Q5: I choose options 1.A to setup the environment, and it is running out of disk memory, what would I do? Answer: You have two options. 1, You can choose to install a Ubuntu inside of VirtualBox and start from option 1.B (recommended) 2, you can add a new virtual hard disk to your current virtual machine. Step 1: Follow the instructions in the below link (but skipping the last step - \"mounting the partition\") [ Add Disk Storage ]. Step 2: Run the below command to cleanup some space sudo rm -rf /var/* Step 3. Run the below command to mount the new disk to the home directory. sudo mount /dev/sdb1 ~ Q6: Why does admin.peers return null sometimes? admin.peers returns you the information about connected remote nodes and it seems like the method uses public IP addresses for this. Few students mentioned that admin.peers runs successfully when they run it outside of the school network while it failed in the shcool network. Even though it's returning null, you should still be able to mine your own coins if you connected to the private blockchain network successfully. Q7: Out of space? Clear the folder ~/.ethereum/ after you finish the lab. Also, clear the folder specified through ``--datadir'' when starting geth.","title":"FAQ/Trouble shooting"},{"location":"labs/A3/address_updates/","text":"genesis.json { \"config\": { \"chainId\": 89992018, \"homesteadBlock\": 0, \"eip150Block\": 0, \"eip155Block\": 0, \"eip158Block\": 0 }, \"alloc\" : {}, \"difficulty\" : \"0x200\", \"gasLimit\" : \"0x2fefd8\" } script 2.1: 4th line geth --datadir bkc_data --networkid 89992018 --bootnodes enode://7320559847736145843099b94c6c67d52c3abd4af42200dde25557d58da3f36358b6a029ff37058461ee5e627aed6fb55386c3e334b54fa35480aee4ea73eb61@128.230.208.73:30301 console 2>console.log script 2.2 admin.addPeer(\"enode://7320559847736145843099b94c6c67d52c3abd4af42200dde25557d58da3f36358b6a029ff37058461ee5e627aed6fb55386c3e334b54fa35480aee4ea73eb61@128.230.208.73:30303\")","title":"Address updates"},{"location":"labs/A3/web3py/","text":"To efficiently retrieve the information stored in your Ethereum node, such as blocks and transactions, you can use Python to work with the Web3py library. Open a new terminal and install python3 sudo apt updates sudo apt upgrades sudo apt install python3.6 Install web3 sudo python3.6 -m pip install web3 Write your own python code (say get_bkc.py ) to retrieve content from your Ethereum node. from web3 import Web3 w3 = Web3(Web3.HTTPProvider('http://127.0.0.1:8545')) for i in range(1, 10): print(w3.eth.getBlock(i)) Execute the above code will print out the first 10 blocks. python3.6 get_bkc.py Note: if executing the above code throws the connection error, that means your geth did not enable the RPC. You can enable RPC by add '--rpc' (or --http) when you start geth in the last command of step 2.1. See the following example. 'geth --datadir bkc_data --rpc --allow-insecure-unlock --networkid 89992018 --bootnodes \"enode://a3b871242d7e40dc517514f6a995c2514cbe4907827275e3164ff43fb95d1d977d77e66da2e992c94a0843337fdfb86c9a02254e414db8ff0d6dbba15f32eb22@128.230.210.231:30301\" console 2>console.log'. or 'geth --datadir bkc_data --http --allow-insecure-unlock --networkid 89992018 --bootnodes \"enode://a3b871242d7e40dc517514f6a995c2514cbe4907827275e3164ff43fb95d1d977d77e66da2e992c94a0843337fdfb86c9a02254e414db8ff0d6dbba15f32eb22@128.230.210.231:30301\" console 2>console.log'. More web3py functions for working with Ethereum can be found at https://web3py.readthedocs.io/en/stable/web3.eth.html.","title":"Web3py"},{"location":"labs/B1/","text":"Lab B1: DEX 1: Swap settlement Introduction DEX or decentralized exchange supports the swap of token ownership between different accounts. A swap is essentially two transfers, one from Alice to Bob and the other from Bob to Alice. A swap is supposed to be atomic, in the sense that either both transfers occur or no transfer occurs. In this lab, you are going to implement a DEX supporting atomic swap settlement. Exercises CS student Finance student 1 Required Required 2 Required Required 3 Required Bonus (50%) 4 Required Bonus (50%) 5 Bonus (50%) Bonus (100%) Exercise 1. Execute token transfer The following smart contract implements a very simple token supporting the essential transfer function: transfer(address sender, address recipient, uint256 amount) pragma solidity >=0.7.0 <0.9.0; contract MyToken { uint _totalSupply = 0; string _symbol; mapping(address => uint) balances; constructor(string memory symbol, uint256 initialSupply) { _symbol = symbol; _totalSupply = initialSupply; balances[msg.sender] = _totalSupply; } function transfer(address receiver, uint amount) public returns (bool) { require(amount <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender] - amount; balances[receiver] = balances[receiver] + amount; return true; } function balanceOf(address account) public view returns(uint256){ return balances[account]; }} Your job in this exercise is to deploy the above smart contract in Remix, creating an TokenX instance. Demonstrate the process that the TokenX issuer transfers 10 TokenX to another account, say Alice, and display each account's balance before/after the transfer. Exercise 2. Execute atomic swap settlement in one transaction (by escrow EOA) An atomic swap occurs between two accounts in two tokens. Suppose Alice of token TokenX wants to trade her TokenXs for Bob's TokenYs. For simplicity, we assume the exchange rate between TokenX and TokenY is always 1:1 (i.e., one TokenX for one TokenY). A swap incurs a transfer from Alice to Bob in TokenX and another transfer from Bob to Alice in TokenY. A simple swap protocol is to do the two transfers in one transaction. This requires Alice and Bob (two EOAs) first transfer tokens to a trusted third-party account, that is, the escrow. After the escrow receives both Alice's TokenX and Bob's TokenY, the escrow then sends TokenX to Bob and TokenY to Alice, to settle the swap. There are different instanstiation of the escrow protocol. One is to materialize an escrow as an EOA. In this case, the escrow EOA is trusted to send the two transfer calls, atomically. The following figure illustrates the escrow-EOA protocol. Your job in this exercise is to deploy your token smart contracts, from Exercise 1, twice (first as TokenX and then as TokenY). Run the above escrow-EOA protocol to complete the swap of Alice's TokenX and Bob's TokenY. Exercise 3. Design atomic swap settlement in one transaction (by escrow smart contract) Another approach is to impelment the escrow in a smart contract. In this case, after Alice and Bob transfer their tokens to the escrow smart contract (in Step 1 & 2), they then notify the escrow smart contract. After receiving both Alice and Bob's notification, the escrow smart contract sends two transfers, atomically, that is, first to tranfer TokenX to Bob and then to transfer TokenY to Alice. The following figure illustrates the escrow-smart-contract protocol. Your job is to: Implement the escrow smart contract described as above. Then run an atomic swap by deploying the token smart contracts (twice respectively as TokenX and TokenY instances) and the escrow smart contract. Design the failure handling protocol by extending the above escrow smart contract. One failure case is that Alice (or Bob) did not transfer her TokenXs (his TokenYs) to the escrow. In this case, Alice (Bob) should be able to withdraw her TokenXs (his TokenYs) after a predifined timeout, say t blocks. Use block.number to access the current block height in solidity. Hint: To make smart contract X call smart contract Y 's function foo , you can pass to X Y 's contract address say CA_Y so that in X the following statement calls CA_Y 's function foo : (Y)CA_Y.foo(); Exercise 4: Design the swap between token and Ether Revise your escrow smart contract to support the swap between Ether and TokenX. For instance, Alice trades her TokenX for Bob's Ether. Design the protocol as above and implement it in the escrow smart contract. Here, you can assume one TokenX is exchangeable with one Ether. Consider both cases of success and failed swaps. Deliverable For all exercises, you should 1) submit your smart-contract code, and 2) show the screenshot of the program execution.","title":"Lab B1. DEX 1: Swap settlement"},{"location":"labs/B1/#lab-b1-dex-1-swap-settlement","text":"","title":"Lab B1: DEX 1: Swap settlement"},{"location":"labs/B1/#introduction","text":"DEX or decentralized exchange supports the swap of token ownership between different accounts. A swap is essentially two transfers, one from Alice to Bob and the other from Bob to Alice. A swap is supposed to be atomic, in the sense that either both transfers occur or no transfer occurs. In this lab, you are going to implement a DEX supporting atomic swap settlement. Exercises CS student Finance student 1 Required Required 2 Required Required 3 Required Bonus (50%) 4 Required Bonus (50%) 5 Bonus (50%) Bonus (100%)","title":"Introduction"},{"location":"labs/B1/#exercise-1-execute-token-transfer","text":"The following smart contract implements a very simple token supporting the essential transfer function: transfer(address sender, address recipient, uint256 amount) pragma solidity >=0.7.0 <0.9.0; contract MyToken { uint _totalSupply = 0; string _symbol; mapping(address => uint) balances; constructor(string memory symbol, uint256 initialSupply) { _symbol = symbol; _totalSupply = initialSupply; balances[msg.sender] = _totalSupply; } function transfer(address receiver, uint amount) public returns (bool) { require(amount <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender] - amount; balances[receiver] = balances[receiver] + amount; return true; } function balanceOf(address account) public view returns(uint256){ return balances[account]; }} Your job in this exercise is to deploy the above smart contract in Remix, creating an TokenX instance. Demonstrate the process that the TokenX issuer transfers 10 TokenX to another account, say Alice, and display each account's balance before/after the transfer.","title":"Exercise 1. Execute token transfer"},{"location":"labs/B1/#exercise-2-execute-atomic-swap-settlement-in-one-transaction-by-escrow-eoa","text":"An atomic swap occurs between two accounts in two tokens. Suppose Alice of token TokenX wants to trade her TokenXs for Bob's TokenYs. For simplicity, we assume the exchange rate between TokenX and TokenY is always 1:1 (i.e., one TokenX for one TokenY). A swap incurs a transfer from Alice to Bob in TokenX and another transfer from Bob to Alice in TokenY. A simple swap protocol is to do the two transfers in one transaction. This requires Alice and Bob (two EOAs) first transfer tokens to a trusted third-party account, that is, the escrow. After the escrow receives both Alice's TokenX and Bob's TokenY, the escrow then sends TokenX to Bob and TokenY to Alice, to settle the swap. There are different instanstiation of the escrow protocol. One is to materialize an escrow as an EOA. In this case, the escrow EOA is trusted to send the two transfer calls, atomically. The following figure illustrates the escrow-EOA protocol. Your job in this exercise is to deploy your token smart contracts, from Exercise 1, twice (first as TokenX and then as TokenY). Run the above escrow-EOA protocol to complete the swap of Alice's TokenX and Bob's TokenY.","title":"Exercise 2. Execute atomic swap settlement in one transaction (by escrow EOA)"},{"location":"labs/B1/#exercise-3-design-atomic-swap-settlement-in-one-transaction-by-escrow-smart-contract","text":"Another approach is to impelment the escrow in a smart contract. In this case, after Alice and Bob transfer their tokens to the escrow smart contract (in Step 1 & 2), they then notify the escrow smart contract. After receiving both Alice and Bob's notification, the escrow smart contract sends two transfers, atomically, that is, first to tranfer TokenX to Bob and then to transfer TokenY to Alice. The following figure illustrates the escrow-smart-contract protocol. Your job is to: Implement the escrow smart contract described as above. Then run an atomic swap by deploying the token smart contracts (twice respectively as TokenX and TokenY instances) and the escrow smart contract. Design the failure handling protocol by extending the above escrow smart contract. One failure case is that Alice (or Bob) did not transfer her TokenXs (his TokenYs) to the escrow. In this case, Alice (Bob) should be able to withdraw her TokenXs (his TokenYs) after a predifined timeout, say t blocks. Use block.number to access the current block height in solidity. Hint: To make smart contract X call smart contract Y 's function foo , you can pass to X Y 's contract address say CA_Y so that in X the following statement calls CA_Y 's function foo : (Y)CA_Y.foo();","title":"Exercise 3. Design atomic swap settlement in one transaction (by escrow smart contract)"},{"location":"labs/B1/#exercise-4-design-the-swap-between-token-and-ether","text":"Revise your escrow smart contract to support the swap between Ether and TokenX. For instance, Alice trades her TokenX for Bob's Ether. Design the protocol as above and implement it in the escrow smart contract. Here, you can assume one TokenX is exchangeable with one Ether. Consider both cases of success and failed swaps.","title":"Exercise 4: Design the swap between token and Ether"},{"location":"labs/B1/#deliverable","text":"For all exercises, you should 1) submit your smart-contract code, and 2) show the screenshot of the program execution.","title":"Deliverable"},{"location":"labs/B1/README-lab4/","text":"Lab 4: Atomic Multi-tx Swaps on HTLC Introduction Swapping the ownership of two tokens on two accounts is a fundamental DeFi service. While swap atomicity in DEX is enforced by having two transfers done in a single transaction, there are practical scenarios where a swap of two accounts' ownership needs to be done in two transactions. An example is cross-chain swaps. In this lab, you will implement a multi-transaction swap using HTLC. Task 1. Implement an HTLC HTLC or hash time lock contract is parameterized by hash h , timeout t , sender account A and receiver account B . HTLC(h,t,A,B,2mToken) stores a deposit of 2 mTokens and there are two outcomes: 1) before the timeout t , if the HTLC smart contract receives receiver B 's transaction revealing secret s such that h=H(s) , the 2 mTokens will be transferred to B 's account. 2) after the timeout t , if case 1) did not happen, the HTLC smart contract returns the deposit to sender A . Your job is to implement HTLC smart contract. Task 2. Execute atomic multi-tx swap using two HTLC's An atomic multi-transaction swap can run based on two HTLC smart contracts. The protocol is described in the figure below. Run the above atomic swap protocol based on your HTLC smart contracts implemented in Task 1. Deliverable For all tasks, you should 1) submit your smart-contract code, and 2) show the screenshot of the program execution.","title":"README lab4"},{"location":"labs/B1/README-lab4/#lab-4-atomic-multi-tx-swaps-on-htlc","text":"","title":"Lab 4: Atomic Multi-tx Swaps on HTLC"},{"location":"labs/B1/README-lab4/#introduction","text":"Swapping the ownership of two tokens on two accounts is a fundamental DeFi service. While swap atomicity in DEX is enforced by having two transfers done in a single transaction, there are practical scenarios where a swap of two accounts' ownership needs to be done in two transactions. An example is cross-chain swaps. In this lab, you will implement a multi-transaction swap using HTLC.","title":"Introduction"},{"location":"labs/B1/README-lab4/#task-1-implement-an-htlc","text":"HTLC or hash time lock contract is parameterized by hash h , timeout t , sender account A and receiver account B . HTLC(h,t,A,B,2mToken) stores a deposit of 2 mTokens and there are two outcomes: 1) before the timeout t , if the HTLC smart contract receives receiver B 's transaction revealing secret s such that h=H(s) , the 2 mTokens will be transferred to B 's account. 2) after the timeout t , if case 1) did not happen, the HTLC smart contract returns the deposit to sender A . Your job is to implement HTLC smart contract.","title":"Task 1. Implement an HTLC"},{"location":"labs/B1/README-lab4/#task-2-execute-atomic-multi-tx-swap-using-two-htlcs","text":"An atomic multi-transaction swap can run based on two HTLC smart contracts. The protocol is described in the figure below. Run the above atomic swap protocol based on your HTLC smart contracts implemented in Task 1.","title":"Task 2. Execute atomic multi-tx swap using two HTLC's"},{"location":"labs/B1/README-lab4/#deliverable","text":"For all tasks, you should 1) submit your smart-contract code, and 2) show the screenshot of the program execution.","title":"Deliverable"},{"location":"labs/B1/README-old-1/","text":"Lab 4: Escrow Services and Applications Introduction An escrow is a trusted service that manages counter-party risks and helps establish trust between untrusted seller and buyer. In real life, an escrow service is backed by banks and is useful in many financial and supply-chain scenarios (e.g., buying a house). In this lab, you are required to implement an escrow service on Ether and custom tokens. System design There are four parties involved in an escrow service: a buyer, a seller, the escrow service and an arbitrator. The protocol works as below: At the beginning, the buyer makes a security deposit to the escrow service. Then, it proceeds to execute the transaction between the buyer and seller. In the end, if both the seller and buyer agree on the successful execution of transaction, the escrow service will transfer the payment to the seller. There is also a chance that the buyer and seller have a dispute; in this case, the escrow service hold back from sending the payment to the seller and relies on a trusted party to arbitrate the transaction outcome. Depending on the outcome, it may refund the buyer or pay to the seller. In practice, a real-world arbitrator can be an insurance company. The workflow of escrow service is listed below: The buyer sends a security deposit to the escrow service. (Case 1): The transaction is successful and is agreed upon between the buyer and the seller. Signaled by both parties, the escrow service proceeds to send the deposit to the seller. (Case 2): The transaction fails and the failed state is agreed upon between the buyer and seller. Signaled by both parties, the escrow service proceeds to refund the buyer. (Case 3): There is a dispute about the state of transaction. For instance, the buyer may think the transaction finishes successfully but the seller may think the opposite. In this case, an off-chain trusted party is used to arbitrate the transaction state and will tell the escrow service of her decision. Depending on the result, the escrow service may refund the buyer or pay the seller. Note that in all cases, the escrow service should collect certain amount of security deposit for the service fee (e.g., 1% of the security deposit). Refer to [ link ] and [ link ] for more details about the escrow services. A natural design is to implement a smart contract to play the role of escrow service. Here, your escrow smart contract should manage, in addition to its own address, three external accounts ( EOA ): a seller, a buyer and an arbitrator. Each account is associated with balance in certain tokens . For simplest impl., you can hard-code the buyer/seller addresses, and use Ether as the default token. Task 1: Buyer and seller agree on the transaction state Impl. the smart escrow contract that supports the following functions: MakeDeposit() which allows the buyer to send the payment/security deposit to the smart contract. The payment should be the price of product plus service fee (1%). ApproveTxSuccess() which allows only the buyer or seller to send their approval and to signal the success of transaction. Only both parties approve, the contract sends the payment to the seller. ApproveTxFail() which allows only the buyer or seller to send their approval and to signal the failure of transaction. Only both parties approve, the contract refunds the payment back to the buyer. Task 2: Dispute resolution Dispute occurs when the seller sends ApproveTxFail() and the buyer sends ApproveTxSuccess() (or vice versa). When this happens, the escrow contract enters the following time-lock logic: It will wait for the input of an off-chain arbitrator via function Arbitrate() . If such an input is not received for the 2 minutes, the contract will time-out and refund the deposit to the buyer. Implement Function Timelock() , such that the smart contract waits for 2 minutes (or 12 Ethereum blocks) for the event of Arbitrate() invocation. If the timeout is reached, it refunds. The function Timelock() can be called by ApproveTxSuccess() / ApproveTxFail() after a dispute state occurs and should do two things: Record current time/block height (depends on how you're measuring the time) Change the transaction state to dispute (Transaction is marked as dispute) Implement Function Arbitrate() which is supposed to be called by account arbitrator. The arbitrator decides the transaction state and the function takes action to refund the buyer (upon the transaction failure) and to pay for the seller (upon the transaction success). Arbitrate() method should check the difference between time/block heights in addition to the transaction state Task 3: Support custom tokens In this task, you are required to implement a simple token and use it to support the smart escrow contract. Implement a simple token contract SimpleToken that supports function transfer(address sender, address recipient, uint256 amount) Use the token to back the accounts of buyer and seller in the smart escrow contract. Bonus Task (20%) Deploy and run the code of all previous tasks on our on-campus Blockchain. Include screenshots of the results in your report. You can use [ this tutorial ] as a reference of how to deploy smart contracts on the on-campus Blockchain. Deliverable For all tasks, you should 1) submit your smart-contract code, and 2) show the screenshot of the program execution. Q/A How to implement timeout on smart contract? Hint: You can rely on the off-chain arbitrator to trigger the timeout function and use block.number to check if the timeout is called appropriately. How can the \"broker\"account send ether to either the seller account, or refund ether back to the buyer account? Hint: You can use functions address.transfer() or address.send() . Such a function transfers ether from the broker-contract account to the address , which can be either seller or buyer account. Hint: To send ether to the broker contract, you can send a regular transaction from off-chain.","title":"README old 1"},{"location":"labs/B1/README-old-1/#lab-4-escrow-services-and-applications","text":"","title":"Lab 4: Escrow Services and Applications"},{"location":"labs/B1/README-old-1/#introduction","text":"An escrow is a trusted service that manages counter-party risks and helps establish trust between untrusted seller and buyer. In real life, an escrow service is backed by banks and is useful in many financial and supply-chain scenarios (e.g., buying a house). In this lab, you are required to implement an escrow service on Ether and custom tokens.","title":"Introduction"},{"location":"labs/B1/README-old-1/#system-design","text":"There are four parties involved in an escrow service: a buyer, a seller, the escrow service and an arbitrator. The protocol works as below: At the beginning, the buyer makes a security deposit to the escrow service. Then, it proceeds to execute the transaction between the buyer and seller. In the end, if both the seller and buyer agree on the successful execution of transaction, the escrow service will transfer the payment to the seller. There is also a chance that the buyer and seller have a dispute; in this case, the escrow service hold back from sending the payment to the seller and relies on a trusted party to arbitrate the transaction outcome. Depending on the outcome, it may refund the buyer or pay to the seller. In practice, a real-world arbitrator can be an insurance company. The workflow of escrow service is listed below: The buyer sends a security deposit to the escrow service. (Case 1): The transaction is successful and is agreed upon between the buyer and the seller. Signaled by both parties, the escrow service proceeds to send the deposit to the seller. (Case 2): The transaction fails and the failed state is agreed upon between the buyer and seller. Signaled by both parties, the escrow service proceeds to refund the buyer. (Case 3): There is a dispute about the state of transaction. For instance, the buyer may think the transaction finishes successfully but the seller may think the opposite. In this case, an off-chain trusted party is used to arbitrate the transaction state and will tell the escrow service of her decision. Depending on the result, the escrow service may refund the buyer or pay the seller. Note that in all cases, the escrow service should collect certain amount of security deposit for the service fee (e.g., 1% of the security deposit). Refer to [ link ] and [ link ] for more details about the escrow services. A natural design is to implement a smart contract to play the role of escrow service. Here, your escrow smart contract should manage, in addition to its own address, three external accounts ( EOA ): a seller, a buyer and an arbitrator. Each account is associated with balance in certain tokens . For simplest impl., you can hard-code the buyer/seller addresses, and use Ether as the default token.","title":"System design"},{"location":"labs/B1/README-old-1/#task-1-buyer-and-seller-agree-on-the-transaction-state","text":"Impl. the smart escrow contract that supports the following functions: MakeDeposit() which allows the buyer to send the payment/security deposit to the smart contract. The payment should be the price of product plus service fee (1%). ApproveTxSuccess() which allows only the buyer or seller to send their approval and to signal the success of transaction. Only both parties approve, the contract sends the payment to the seller. ApproveTxFail() which allows only the buyer or seller to send their approval and to signal the failure of transaction. Only both parties approve, the contract refunds the payment back to the buyer.","title":"Task 1: Buyer and seller agree on the transaction state"},{"location":"labs/B1/README-old-1/#task-2-dispute-resolution","text":"Dispute occurs when the seller sends ApproveTxFail() and the buyer sends ApproveTxSuccess() (or vice versa). When this happens, the escrow contract enters the following time-lock logic: It will wait for the input of an off-chain arbitrator via function Arbitrate() . If such an input is not received for the 2 minutes, the contract will time-out and refund the deposit to the buyer. Implement Function Timelock() , such that the smart contract waits for 2 minutes (or 12 Ethereum blocks) for the event of Arbitrate() invocation. If the timeout is reached, it refunds. The function Timelock() can be called by ApproveTxSuccess() / ApproveTxFail() after a dispute state occurs and should do two things: Record current time/block height (depends on how you're measuring the time) Change the transaction state to dispute (Transaction is marked as dispute) Implement Function Arbitrate() which is supposed to be called by account arbitrator. The arbitrator decides the transaction state and the function takes action to refund the buyer (upon the transaction failure) and to pay for the seller (upon the transaction success). Arbitrate() method should check the difference between time/block heights in addition to the transaction state","title":"Task 2: Dispute resolution"},{"location":"labs/B1/README-old-1/#task-3-support-custom-tokens","text":"In this task, you are required to implement a simple token and use it to support the smart escrow contract. Implement a simple token contract SimpleToken that supports function transfer(address sender, address recipient, uint256 amount) Use the token to back the accounts of buyer and seller in the smart escrow contract.","title":"Task 3: Support custom tokens"},{"location":"labs/B1/README-old-1/#bonus-task-20","text":"Deploy and run the code of all previous tasks on our on-campus Blockchain. Include screenshots of the results in your report. You can use [ this tutorial ] as a reference of how to deploy smart contracts on the on-campus Blockchain.","title":"Bonus Task (20%)"},{"location":"labs/B1/README-old-1/#deliverable","text":"For all tasks, you should 1) submit your smart-contract code, and 2) show the screenshot of the program execution.","title":"Deliverable"},{"location":"labs/B1/README-old-1/#qa","text":"How to implement timeout on smart contract? Hint: You can rely on the off-chain arbitrator to trigger the timeout function and use block.number to check if the timeout is called appropriately. How can the \"broker\"account send ether to either the seller account, or refund ether back to the buyer account? Hint: You can use functions address.transfer() or address.send() . Such a function transfers ether from the broker-contract account to the address , which can be either seller or buyer account. Hint: To send ether to the broker contract, you can send a regular transaction from off-chain.","title":"Q/A"},{"location":"labs/B1/lab5/","text":"Lab 5: Price Oracle and Liquidation A lending pool service allows borrowers to borrow one asset and collateralize another asset. To ensure that the value of the collateral matches that of the asset borrowed, the lending pool relies on a liquidation mechanism. In this lab, you will implement a simple lending pool and a liquidation mechanism between ETH and an ERC20 token. The liquidation requires reading from an off-chain oracle the price ticks of the current exchange rates between the token and ETH. More specifically, the figure depicts common workflows in a lending pool service. This workflow has two smart contracts and three EOAs: a borrower EOA, an oracle EOA, and a liquidator EOA. The two smart contracts are the tToken smart contracts and the lending-pool smart contract (LP). There are three workflows in this system; 1) the borrower borrowing tToken by collateral of ETH, 2) the price oracle updates the current price on the LP smart contract, and triggers liquidation, 3) the liquidator deposit tToken to claim the ETH collateral at a lower exchange rate. In this lab, you will implement the three workflows in an overall functional system. Task 1: Borrow Write smart contracts LP and tToken to support the following workflow: Initially, the LP smart contract has more than 10X tTokens. On Day One, the borrower calls the \"borrow\" function in the LP smart contract. Suppose through this function call (also a transaction), the borrower sends X ETH to the LP, and the X ETH is worth 4X tToken (that is, the ETH-tToken exchange rate on Day One is 4:1). The LP allows to lend at most 2X tToken to the borrower. This workflow is shown by Step 1) in the figure. Task 2: Price feed Add a \"feedPriceTick\" function to your LP from Task 1, so that it supports the following workflow: The Oracle EOA can call the \"feedPriceTick\" with value T to set the current exchange rate between tToken and ETH. After the exchange rate is updated, the feedPriceTick function may calculate the current value of the ETH collateral in tToken. If it finds the ETH's worth is less than 3X tTokens, it sets the liquidation flag. This workflow is shown by Step 2) in the figure. Task 3: Liquidation Add a \"liquidate\" function to your LP from Task 2, so that it supports the following workflow: A liquidator EOA transfers 2X tTokens to LP's account. This can be done by having the EOA call the tToken's \"transfer\" function (this is Step 3a in the figure). Then, the EOA calls the LP's \"liquidate\" function, which first checks the liquidation flag, and if true, proceeds to transfer X ETH to the liquidator's EOA account (Step 3b in the figure). Deliverable For all tasks, you should show the screenshot that you have executed the described workflow successfully. Submit your solidity program.","title":"Lab5"},{"location":"labs/B1/lab5/#lab-5-price-oracle-and-liquidation","text":"A lending pool service allows borrowers to borrow one asset and collateralize another asset. To ensure that the value of the collateral matches that of the asset borrowed, the lending pool relies on a liquidation mechanism. In this lab, you will implement a simple lending pool and a liquidation mechanism between ETH and an ERC20 token. The liquidation requires reading from an off-chain oracle the price ticks of the current exchange rates between the token and ETH. More specifically, the figure depicts common workflows in a lending pool service. This workflow has two smart contracts and three EOAs: a borrower EOA, an oracle EOA, and a liquidator EOA. The two smart contracts are the tToken smart contracts and the lending-pool smart contract (LP). There are three workflows in this system; 1) the borrower borrowing tToken by collateral of ETH, 2) the price oracle updates the current price on the LP smart contract, and triggers liquidation, 3) the liquidator deposit tToken to claim the ETH collateral at a lower exchange rate. In this lab, you will implement the three workflows in an overall functional system.","title":"Lab 5: Price Oracle and Liquidation"},{"location":"labs/B1/lab5/#task-1-borrow","text":"Write smart contracts LP and tToken to support the following workflow: Initially, the LP smart contract has more than 10X tTokens. On Day One, the borrower calls the \"borrow\" function in the LP smart contract. Suppose through this function call (also a transaction), the borrower sends X ETH to the LP, and the X ETH is worth 4X tToken (that is, the ETH-tToken exchange rate on Day One is 4:1). The LP allows to lend at most 2X tToken to the borrower. This workflow is shown by Step 1) in the figure.","title":"Task 1: Borrow"},{"location":"labs/B1/lab5/#task-2-price-feed","text":"Add a \"feedPriceTick\" function to your LP from Task 1, so that it supports the following workflow: The Oracle EOA can call the \"feedPriceTick\" with value T to set the current exchange rate between tToken and ETH. After the exchange rate is updated, the feedPriceTick function may calculate the current value of the ETH collateral in tToken. If it finds the ETH's worth is less than 3X tTokens, it sets the liquidation flag. This workflow is shown by Step 2) in the figure.","title":"Task 2: Price feed"},{"location":"labs/B1/lab5/#task-3-liquidation","text":"Add a \"liquidate\" function to your LP from Task 2, so that it supports the following workflow: A liquidator EOA transfers 2X tTokens to LP's account. This can be done by having the EOA call the tToken's \"transfer\" function (this is Step 3a in the figure). Then, the EOA calls the LP's \"liquidate\" function, which first checks the liquidation flag, and if true, proceeds to transfer X ETH to the liquidator's EOA account (Step 3b in the figure).","title":"Task 3: Liquidation"},{"location":"labs/B1/lab5/#deliverable","text":"For all tasks, you should show the screenshot that you have executed the described workflow successfully. Submit your solidity program.","title":"Deliverable"},{"location":"labs/B1/lab6/","text":"Lab 6: Auctions Excercise 1 In this exercise, you are expected to design an open auction smart contract openAuction using solidity programing language. In an open auction, every participant is able to see the highest bid in the current period. Your code should implement the following logic. Your contract constructor function should specify how long the bidding time will be and who will be the beneficiary . A function submitBid() can accept bids from any pariticipants and accepts their deposits within the bidding time. After the bidding time elapsed, no one can submit bids. The function only accepts a bid that beats the current highest bid. Within the bidding time, each bidder can submit bids multiple times. A funcion auctionEnd() can be called after the bidding time which will select the bidder who submits the second highest bid as the winner. His deposit is transfered to the beneficiary. The other bidders losing the auction is able to call the withdraw() function to take back their deposits. Excersice 2 In this excercise, you are required to implement a blinded auction protocol and write a blindAuction smart contract. In a blinded auction, paritipants are not allowed to see other bidders' bids and the highest bid. There will be two time periods, the first one is called bidding period, within which each pariticipant can submit a hash string to represent their bids. The other is called reveal period, within which each pariticipant need to reveal their real bids (the preimage of submitted hash). The bidding period starts and ends strictly before the reveal period. Your contract should implement the following logic. The contract deployer specifies the bidding time , reveal time , and beneficiary . The insterested bidders should hide their real bids by submitting a hash and transfer an arbitrary amount of value as the deposit. Specifically, the hash can be computed from a triplet of [fake (boolean), amount (int), secret(bytes32)]), each bidder needs to call this function multiple times to submit different hashes (computed from different triplets) to hide their real bids. The contract only accept bids during the bidding period, and after that no one can submit bids and the reveal timer ticker starts. During the reveal period, each bidder need to reveal each of their previous submitted hash by sending the raw triplets to the contract. The contract then check if the hash of each raw triplet equals to each previously submitted hash. If not, the contract do not allow the bidder to withdraw the corresponding deposits in that unmatched bid. After the reveal period, the second highest bidder will be the winner and his deposit will be transfered to the beneficiary. The other bidders losing the auction withdraw their deposits. Hints : 1. You can implemment a pure function to compute the hash string for any given triplets and then submit the hash as a blinded bid. 2. The bidders' deposits should be sent to the contract during bidding period. No deposit will be allowed after bidding peroid. 3. During the reveal period, if two bids have the same amount of deposit that equal to the highest bid, then who submits the bid later will be the winner. Similarly, if there are three or more bidders, then who submits the bid in the second earlist timestamp will be the winner. 4. Similarly, during the reveal period, if the highest bid does not have two bidders but the second highest bid has, then who submits the second highest bid in the earlist timestamp will be the winner. FAQ 1. If there is no valid bid, what should the smart contract do? The auction will fail and there is no winner. 2. If there is only one valid bid, what should the smart contract do? The auction will fail and there is no winner. Deliverable For all exercises, you should show the screenshot that you can execute your program successfully. For instance, in Exercise 1, your screenshort should show the execution of that different bidders submiting bids of different amounts, and the second highest bid wins the auction. In Exercise 2, your screenshort should show the execution of that different bidders submiting different hashes and revealing the preimage of the submitted hashes. Then the second highest bid wins the auction. You should also submit the solidity program you wrote.","title":"Lab 6: Auctions"},{"location":"labs/B1/lab6/#lab-6-auctions","text":"","title":"Lab 6: Auctions"},{"location":"labs/B1/lab6/#excercise-1","text":"In this exercise, you are expected to design an open auction smart contract openAuction using solidity programing language. In an open auction, every participant is able to see the highest bid in the current period. Your code should implement the following logic. Your contract constructor function should specify how long the bidding time will be and who will be the beneficiary . A function submitBid() can accept bids from any pariticipants and accepts their deposits within the bidding time. After the bidding time elapsed, no one can submit bids. The function only accepts a bid that beats the current highest bid. Within the bidding time, each bidder can submit bids multiple times. A funcion auctionEnd() can be called after the bidding time which will select the bidder who submits the second highest bid as the winner. His deposit is transfered to the beneficiary. The other bidders losing the auction is able to call the withdraw() function to take back their deposits.","title":"Excercise 1"},{"location":"labs/B1/lab6/#excersice-2","text":"In this excercise, you are required to implement a blinded auction protocol and write a blindAuction smart contract. In a blinded auction, paritipants are not allowed to see other bidders' bids and the highest bid. There will be two time periods, the first one is called bidding period, within which each pariticipant can submit a hash string to represent their bids. The other is called reveal period, within which each pariticipant need to reveal their real bids (the preimage of submitted hash). The bidding period starts and ends strictly before the reveal period. Your contract should implement the following logic. The contract deployer specifies the bidding time , reveal time , and beneficiary . The insterested bidders should hide their real bids by submitting a hash and transfer an arbitrary amount of value as the deposit. Specifically, the hash can be computed from a triplet of [fake (boolean), amount (int), secret(bytes32)]), each bidder needs to call this function multiple times to submit different hashes (computed from different triplets) to hide their real bids. The contract only accept bids during the bidding period, and after that no one can submit bids and the reveal timer ticker starts. During the reveal period, each bidder need to reveal each of their previous submitted hash by sending the raw triplets to the contract. The contract then check if the hash of each raw triplet equals to each previously submitted hash. If not, the contract do not allow the bidder to withdraw the corresponding deposits in that unmatched bid. After the reveal period, the second highest bidder will be the winner and his deposit will be transfered to the beneficiary. The other bidders losing the auction withdraw their deposits. Hints : 1. You can implemment a pure function to compute the hash string for any given triplets and then submit the hash as a blinded bid. 2. The bidders' deposits should be sent to the contract during bidding period. No deposit will be allowed after bidding peroid. 3. During the reveal period, if two bids have the same amount of deposit that equal to the highest bid, then who submits the bid later will be the winner. Similarly, if there are three or more bidders, then who submits the bid in the second earlist timestamp will be the winner. 4. Similarly, during the reveal period, if the highest bid does not have two bidders but the second highest bid has, then who submits the second highest bid in the earlist timestamp will be the winner. FAQ 1. If there is no valid bid, what should the smart contract do? The auction will fail and there is no winner. 2. If there is only one valid bid, what should the smart contract do? The auction will fail and there is no winner.","title":"Excersice 2"},{"location":"labs/B1/lab6/#deliverable","text":"For all exercises, you should show the screenshot that you can execute your program successfully. For instance, in Exercise 1, your screenshort should show the execution of that different bidders submiting bids of different amounts, and the second highest bid wins the auction. In Exercise 2, your screenshort should show the execution of that different bidders submiting different hashes and revealing the preimage of the submitted hashes. Then the second highest bid wins the auction. You should also submit the solidity program you wrote.","title":"Deliverable"},{"location":"labs/B2/","text":"Lab B2: DEX 2: AMM and Pricing Introduction An automated market maker (AMM) is a decentralized-exchange (DEX) protocol. In an AMM, a trader does not directly trade with other traders. Instead, they trade with a smart-contract intermediary. In practice, AMM gets more widely adopted than other DEX forms (e.g., order book). For instance, the most popular DEX services, including Uniswap, Sushiswap, Pancakeswap, etc., all follow AMM protocols. In this lab, you will implement an AMM smart contract. Tasks Points CS student Finance student 1 20 Required Bonus 2 30 Required Bonus 3 50 Required Bonus Exercise 1. Execute token transfer (same with B1) The following smart contract implements a very simple token supporting the essential transfer function: transfer(address sender, address recipient, uint256 amount) pragma solidity >=0.7.0 <0.9.0; contract MyToken { uint _totalSupply = 0; string _symbol; mapping(address => uint) balances; constructor(string memory symbol, uint256 initialSupply) { _symbol = symbol; _totalSupply = initialSupply; balances[msg.sender] = _totalSupply; } function transfer(address receiver, uint amount) public returns (bool) { require(amount <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender] - amount; balances[receiver] = balances[receiver] + amount; return true; } function balanceOf(address account) public view returns(uint256){ return balances[account]; }} Your job in this exercise is to deploy the above smart contract in Remix, creating an TokenX instance. Demonstrate the process that the TokenX issuer transfers 10 TokenX to another account, say Alice, and display each account's balance before/after the transfer. Exercise 2. Impl. an fixed-rate AMM (1:2) In the figure above, trader Alice first transfers dx units of TokenX from her account to an AMM pool's account. Then, she calls the AMM smart contract's function trySwap(dx) . Upon receiving Alice's transaction, the AMM smart contract internally calls TokenY's transfer function to transfer dy units of TokenY to Alice's account. In this exercise, you can consider that dy/dx = 2. Implement the AMM smart contract. pragma solidity >=0.7.0 <0.9.0; contract AMM { MyToken tokenX, tokenY; // _tokenX and _tokenY are contract-addresses running MyToken SC constructor(address _tokenX, address _tokenY){ tokenX = MyToken(_tokenX); tokenY = MyToken(_tokenY); } function swapXY(uint amountX) public payable { // fill out the following with your code } } Workflow to execuse your code: Write and compile an AMM smart contract. Deploy MyToken smart contract twice, respectively to two contract addresses, say _tokenX and _tokenY . Deploy AMM smart contract with _tokenX and _tokenY . Execute the smart contracts in two steps: 1) call _tokenX 's transfer function 2) call AMM 's swapXY function Hint: You need to make sure your account has enough tokens for both _tokenX and _tokenY . Exercise 3. Impl. constant-product AMM Suppose the AMM account owns x units of TokenX and y units of TokenY. The AMM pool can use a function f(x,y) to calculate the exchange rate between TokenX and TokenY on the fly. Specifically, it enforces that function value is constant before and after each token swap, that is, f(x,y)=f(x+dx,y-dy) In this exercise, you are asked to implement constant-product AMM (adopted in the real-life Uniswap), where f(x,y)=x*y . Modify your AMM smart contract to support x*y=(x+dx)(y-dy) . Hint: You may want to keep track of token balance x and y in the AMM smart contact by issuing balanceOf in each swapXY call. Deliverable For all tasks, you should 1) submit your smart-contract code, and 2) show the screenshot of the program execution.","title":"Lab B2. DEX 2: AMM and pricing"},{"location":"labs/B2/#lab-b2-dex-2-amm-and-pricing","text":"","title":"Lab B2: DEX 2: AMM and Pricing"},{"location":"labs/B2/#introduction","text":"An automated market maker (AMM) is a decentralized-exchange (DEX) protocol. In an AMM, a trader does not directly trade with other traders. Instead, they trade with a smart-contract intermediary. In practice, AMM gets more widely adopted than other DEX forms (e.g., order book). For instance, the most popular DEX services, including Uniswap, Sushiswap, Pancakeswap, etc., all follow AMM protocols. In this lab, you will implement an AMM smart contract. Tasks Points CS student Finance student 1 20 Required Bonus 2 30 Required Bonus 3 50 Required Bonus","title":"Introduction"},{"location":"labs/B2/#exercise-1-execute-token-transfer-same-with-b1","text":"The following smart contract implements a very simple token supporting the essential transfer function: transfer(address sender, address recipient, uint256 amount) pragma solidity >=0.7.0 <0.9.0; contract MyToken { uint _totalSupply = 0; string _symbol; mapping(address => uint) balances; constructor(string memory symbol, uint256 initialSupply) { _symbol = symbol; _totalSupply = initialSupply; balances[msg.sender] = _totalSupply; } function transfer(address receiver, uint amount) public returns (bool) { require(amount <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender] - amount; balances[receiver] = balances[receiver] + amount; return true; } function balanceOf(address account) public view returns(uint256){ return balances[account]; }} Your job in this exercise is to deploy the above smart contract in Remix, creating an TokenX instance. Demonstrate the process that the TokenX issuer transfers 10 TokenX to another account, say Alice, and display each account's balance before/after the transfer.","title":"Exercise 1. Execute token transfer (same with B1)"},{"location":"labs/B2/#exercise-2-impl-an-fixed-rate-amm-12","text":"In the figure above, trader Alice first transfers dx units of TokenX from her account to an AMM pool's account. Then, she calls the AMM smart contract's function trySwap(dx) . Upon receiving Alice's transaction, the AMM smart contract internally calls TokenY's transfer function to transfer dy units of TokenY to Alice's account. In this exercise, you can consider that dy/dx = 2. Implement the AMM smart contract. pragma solidity >=0.7.0 <0.9.0; contract AMM { MyToken tokenX, tokenY; // _tokenX and _tokenY are contract-addresses running MyToken SC constructor(address _tokenX, address _tokenY){ tokenX = MyToken(_tokenX); tokenY = MyToken(_tokenY); } function swapXY(uint amountX) public payable { // fill out the following with your code } } Workflow to execuse your code: Write and compile an AMM smart contract. Deploy MyToken smart contract twice, respectively to two contract addresses, say _tokenX and _tokenY . Deploy AMM smart contract with _tokenX and _tokenY . Execute the smart contracts in two steps: 1) call _tokenX 's transfer function 2) call AMM 's swapXY function Hint: You need to make sure your account has enough tokens for both _tokenX and _tokenY .","title":"Exercise 2. Impl. an fixed-rate AMM (1:2)"},{"location":"labs/B2/#exercise-3-impl-constant-product-amm","text":"Suppose the AMM account owns x units of TokenX and y units of TokenY. The AMM pool can use a function f(x,y) to calculate the exchange rate between TokenX and TokenY on the fly. Specifically, it enforces that function value is constant before and after each token swap, that is, f(x,y)=f(x+dx,y-dy) In this exercise, you are asked to implement constant-product AMM (adopted in the real-life Uniswap), where f(x,y)=x*y . Modify your AMM smart contract to support x*y=(x+dx)(y-dy) . Hint: You may want to keep track of token balance x and y in the AMM smart contact by issuing balanceOf in each swapXY call.","title":"Exercise 3. Impl. constant-product AMM"},{"location":"labs/B2/#deliverable","text":"For all tasks, you should 1) submit your smart-contract code, and 2) show the screenshot of the program execution.","title":"Deliverable"},{"location":"labs/B3/","text":"Lab B3: DEX security: Arbitrage Introduction In traditional finance, arbitrage is defined as the purchase and sale of the same asset in different markets in order to profit from differences in exchange rate. The same attack applies to decentralized exchanges (DEXes), where an attacker trades with two DEX pools and exercise buy-low-sell-high strategy. In this lab you will pretend to be both the attacker and defender taking steps to exploit an arbitrage opportunity and to prevent it from happening. Task 1. Attack across DEXes Let's assume there are two DEXes, Ottoswap and Cuseswap. Ottoswap was willing to trade 10 TokenX per TokenY and Cuseswap was willing to trade 300 TokenX per TokenY . Attacker Alice could buy 10 TokenX for 1 TokenY from Ottoswap and then trade 10 TokenX for 2 TokenY on Cuseswap yielding a 1 TokenY profit. While Alice can do the two trades in two separate transactions, Alice may face the risk of failing one transaction and losing value. In practice, attackers commonly deploy a smart contract to send the two trade transactions atomically in order to guarantee the attack success and profitability. Your job is to create such an arbitrage smart contract that collects the arbitrage profit. The setting is shown in the above diagram including the two token contracts, TokenX and TokenY , and their exchange rates on the two DEXes (Ottoswap and Cuseswap). Your arbitrage smart contract should invoke Ottoswap's swap function to trade TokenY for TokenX and then invoke Cuseswap's swap function to trade TokenX for TokenX . Your arbitrage smart contract should print its initial balance and the balance in the end. Task 2. Arbitrage Mitigation by Synchronized Swaps In this task you will take the second approach, trading across DEXes to ensure an arbitrage opportunity isn't created. Create a smart contract that routes transactions between Ottoswap and Cuseswap to ensure an exchange imbalance is never created. Include pictures showing the TokenX and TokenY balances of Ottoswap and Cuseswap after your contract executes. Deploy MyToken smart contract twice to create instances of TokenY and TokenX Deploy Ottoswap and Cuseswap Both Ottoswap and Cuseswap have reserves of 10 TokenY and 5 TokenX Fund Alice with 2 TokenY Swap Alice's TokenY on both Ottoswap and Cuseswap simultaneously Deliverable For all tasks, you should submit screenshots showing your contract executing the described workflow successfully. Submit your solidity smart contracts for each task.","title":"Lab B3. DEX security: Arbitrage"},{"location":"labs/B3/#lab-b3-dex-security-arbitrage","text":"","title":"Lab B3: DEX security: Arbitrage"},{"location":"labs/B3/#introduction","text":"In traditional finance, arbitrage is defined as the purchase and sale of the same asset in different markets in order to profit from differences in exchange rate. The same attack applies to decentralized exchanges (DEXes), where an attacker trades with two DEX pools and exercise buy-low-sell-high strategy. In this lab you will pretend to be both the attacker and defender taking steps to exploit an arbitrage opportunity and to prevent it from happening.","title":"Introduction"},{"location":"labs/B3/#task-1-attack-across-dexes","text":"Let's assume there are two DEXes, Ottoswap and Cuseswap. Ottoswap was willing to trade 10 TokenX per TokenY and Cuseswap was willing to trade 300 TokenX per TokenY . Attacker Alice could buy 10 TokenX for 1 TokenY from Ottoswap and then trade 10 TokenX for 2 TokenY on Cuseswap yielding a 1 TokenY profit. While Alice can do the two trades in two separate transactions, Alice may face the risk of failing one transaction and losing value. In practice, attackers commonly deploy a smart contract to send the two trade transactions atomically in order to guarantee the attack success and profitability. Your job is to create such an arbitrage smart contract that collects the arbitrage profit. The setting is shown in the above diagram including the two token contracts, TokenX and TokenY , and their exchange rates on the two DEXes (Ottoswap and Cuseswap). Your arbitrage smart contract should invoke Ottoswap's swap function to trade TokenY for TokenX and then invoke Cuseswap's swap function to trade TokenX for TokenX . Your arbitrage smart contract should print its initial balance and the balance in the end.","title":"Task 1. Attack across DEXes"},{"location":"labs/B3/#task-2-arbitrage-mitigation-by-synchronized-swaps","text":"In this task you will take the second approach, trading across DEXes to ensure an arbitrage opportunity isn't created. Create a smart contract that routes transactions between Ottoswap and Cuseswap to ensure an exchange imbalance is never created. Include pictures showing the TokenX and TokenY balances of Ottoswap and Cuseswap after your contract executes. Deploy MyToken smart contract twice to create instances of TokenY and TokenX Deploy Ottoswap and Cuseswap Both Ottoswap and Cuseswap have reserves of 10 TokenY and 5 TokenX Fund Alice with 2 TokenY Swap Alice's TokenY on both Ottoswap and Cuseswap simultaneously","title":"Task 2. Arbitrage Mitigation by Synchronized Swaps"},{"location":"labs/B3/#deliverable","text":"For all tasks, you should submit screenshots showing your contract executing the described workflow successfully. Submit your solidity smart contracts for each task.","title":"Deliverable"},{"location":"old_labs/lab3.1/","text":"Blockchain Tx Storage Lab Introduction The Blockchain provides the storage of transaction history in cryptocurrency and gives us an interface of reading or writing transactions. In this lab, the learning objective is for students to have a hands-on experience and in-depth understanding of Blockchain's transactional interface. In addition, writing a transaction in Blockchain goes throug mining. This lab also introduces the basic concept of mining. The module consists several exercises and the details are found in [ Blockchain storage lab ]. Recommended Time Supervised situation (e.g. a closely-guided lab session): 1 hour Unsupervised situation (e.g. take a home lab): 1 week Files that are needed You will need the [ genesis.json ] file to execute this lab successfully.","title":"Lab3.1"},{"location":"old_labs/lab3.1/#blockchain-tx-storage-lab","text":"","title":"Blockchain Tx Storage Lab"},{"location":"old_labs/lab3.1/#introduction","text":"The Blockchain provides the storage of transaction history in cryptocurrency and gives us an interface of reading or writing transactions. In this lab, the learning objective is for students to have a hands-on experience and in-depth understanding of Blockchain's transactional interface. In addition, writing a transaction in Blockchain goes throug mining. This lab also introduces the basic concept of mining. The module consists several exercises and the details are found in [ Blockchain storage lab ].","title":"Introduction"},{"location":"old_labs/lab3.1/#recommended-time","text":"Supervised situation (e.g. a closely-guided lab session): 1 hour Unsupervised situation (e.g. take a home lab): 1 week","title":"Recommended Time"},{"location":"old_labs/lab3.1/#files-that-are-needed","text":"You will need the [ genesis.json ] file to execute this lab successfully.","title":"Files that are needed"},{"location":"old_labs/lab3.3/","text":"Blockchain Application Lab: Log Remote File Storage Introduction A common (re)use of Blockchain is to store and audit the log of a remote application. In this lab, the learning objective is for students to have a hands-on experience and in-depth understanding of the use of Blockchain as a audit log. The module consists several exercises and the details are found in [ Blockchain application lab ]. Recommended Time Supervised situation (e.g. a closely-guided lab session): 1 hour Unsupervised situation (e.g. take a home lab): 1 week Pre-requisite [ Blockchain storage lab ].","title":"Lab3.3"},{"location":"old_labs/lab3.3/#blockchain-application-lab-log-remote-file-storage","text":"","title":"Blockchain Application Lab: Log Remote File Storage"},{"location":"old_labs/lab3.3/#introduction","text":"A common (re)use of Blockchain is to store and audit the log of a remote application. In this lab, the learning objective is for students to have a hands-on experience and in-depth understanding of the use of Blockchain as a audit log. The module consists several exercises and the details are found in [ Blockchain application lab ].","title":"Introduction"},{"location":"old_labs/lab3.3/#recommended-time","text":"Supervised situation (e.g. a closely-guided lab session): 1 hour Unsupervised situation (e.g. take a home lab): 1 week","title":"Recommended Time"},{"location":"old_labs/lab3.3/#pre-requisite","text":"[ Blockchain storage lab ].","title":"Pre-requisite"},{"location":"old_labs/lab4.1/","text":"Smart-Contract Programming Lab Introduction Smart contract is an important programming interface of Blockchain. The objective of this lab is for students to have a hands-on experience and in-depth understanding of the smart contract programming. The lab module can be found in [ Smart-contract programming lab ]. Recommended Time Supervised situation (e.g. a closely-guided lab session): 1 hour Unsupervised situation (e.g. take a home lab): 3 days","title":"Lab4.1"},{"location":"old_labs/lab4.1/#smart-contract-programming-lab","text":"","title":"Smart-Contract Programming Lab"},{"location":"old_labs/lab4.1/#introduction","text":"Smart contract is an important programming interface of Blockchain. The objective of this lab is for students to have a hands-on experience and in-depth understanding of the smart contract programming. The lab module can be found in [ Smart-contract programming lab ].","title":"Introduction"},{"location":"old_labs/lab4.1/#recommended-time","text":"Supervised situation (e.g. a closely-guided lab session): 1 hour Unsupervised situation (e.g. take a home lab): 3 days","title":"Recommended Time"},{"location":"old_labs/lab4.2/","text":"Financial Derivative Introduction The goal of this programming lab is to demonstrate the use of smart contract programming in the Banking sector. In this lab, you will create a contract for Financial Derivative given the System Design for the contract and call the functions. The module consists several exercises and the details are found in [ Financial Derivatives ] Recommended Time Supervised situation (e.g. a closely-guided lab session): 1 hour Unsupervised situation (e.g. take a home lab): 1 week","title":"Lab4.2"},{"location":"old_labs/lab4.2/#financial-derivative","text":"","title":"Financial Derivative"},{"location":"old_labs/lab4.2/#introduction","text":"The goal of this programming lab is to demonstrate the use of smart contract programming in the Banking sector. In this lab, you will create a contract for Financial Derivative given the System Design for the contract and call the functions. The module consists several exercises and the details are found in [ Financial Derivatives ]","title":"Introduction"},{"location":"old_labs/lab4.2/#recommended-time","text":"Supervised situation (e.g. a closely-guided lab session): 1 hour Unsupervised situation (e.g. take a home lab): 1 week","title":"Recommended Time"},{"location":"old_labs/lab4.34/","text":"Supply Chain and Escrow Service Introduction The objective of this lab is to understand the use of smart contract programming in Supply chain management. The lab will feature programming exercises for implementing the normal workflow of an escrow service (e.g., deposit and final payment) and the dispute resolution (i.e., returning payment to the buyer). Also, you will create a contract for a supply-chain management system that runs on the on-campus blockchain. The module consists several exercises and the details are found in [ link ]. Recommended Time Supervised situation (e.g. a closely-guided lab session): 2 hour Unsupervised situation (e.g. take a home lab): 1.5 week","title":"Lab4.34"},{"location":"old_labs/lab4.34/#supply-chain-and-escrow-service","text":"","title":"Supply Chain and Escrow Service"},{"location":"old_labs/lab4.34/#introduction","text":"The objective of this lab is to understand the use of smart contract programming in Supply chain management. The lab will feature programming exercises for implementing the normal workflow of an escrow service (e.g., deposit and final payment) and the dispute resolution (i.e., returning payment to the buyer). Also, you will create a contract for a supply-chain management system that runs on the on-campus blockchain. The module consists several exercises and the details are found in [ link ].","title":"Introduction"},{"location":"old_labs/lab4.34/#recommended-time","text":"Supervised situation (e.g. a closely-guided lab session): 2 hour Unsupervised situation (e.g. take a home lab): 1.5 week","title":"Recommended Time"}]}